import{a as R,b as v,c as A}from"./chunk-VAIDCNBY.js";import{a as P,c as y,d as k,e as x}from"./chunk-GLV3F3GR.js";import{a as C,b as l,f as b,i as n,j as I}from"./chunk-TLFJOCN6.js";import{f as $}from"./chunk-IMPGVV52.js";import"./chunk-RWM7Q2YQ.js";import{diffLines as U}from"diff";import{existsSync as h,promises as D}from"fs";import p from"path";import{z as w}from"zod";var O=w.object({component:w.string().optional(),yes:w.boolean(),cwd:w.string().optional()});async function re(t,...e){try{let o=e[0];o&&o.includes("/")&&!o.startsWith("@")&&(o=`@${o}`);let r=O.parse({...t,component:o,cwd:t.cwd??process.cwd()}),a=p.resolve(r.cwd);h(a)||(n.error(`The path ${a} does not exist. Please try again.`),process.exit(1));let f=await C(a);n.debug(`Monorepo detected: ${f.isMonorepo}`);let i=p.resolve(a,"components.json");if(!h(i)&&f.isMonorepo){n.debug("Looking for components.json in monorepo packages...");let s=p.join(a,"packages","ui","components.json");if(h(s))a=p.join(a,"packages","ui"),i=s,n.info(`Detected monorepo. Checking components in ${l.info("packages/ui/")}`),n.break();else if(f.root){let m=p.join(f.root,"packages","ui","components.json");h(m)&&(a=p.join(f.root,"packages","ui"),i=m,n.info(`Detected monorepo. Checking components in ${l.info("packages/ui/")}`),n.break())}}let c=await b(a);if(c||(n.warn(`Configuration is missing. Please run ${l.info("init")} to create a components.json file.`),process.exit(1)),!r.component)await z(c);else{let{registry:s}=$(r.component);if(s)await B(r.component,c);else{let m=await P();m||(I(new Error("Failed to fetch registry index.")),process.exit(1)),await W(r.component,m,c)}}}catch(o){I(o)}}async function z(t){let e=new Map,o=await P();if(o&&e.set(null,o),t.registries)for(let[i,c]of Object.entries(t.registries))try{let s=typeof c=="string"?c:c.url,m=E(s),g=await L(m);g&&e.set(i,g)}catch(s){n.debug(`Failed to fetch index for ${i}:`,s)}e.size===0&&(n.error("Failed to fetch any registry indices."),process.exit(1));let r=[],a=new Set;for(let[i,c]of e)for(let s of c){if(!s.files?.length)continue;let m=F(s,t);if(m.some(u=>a.has(u)))continue;await T(s,t)&&(m.forEach(u=>a.add(u)),r.push({component:s,namespace:i,fullName:i?`${i}/${s.name}`:s.name}))}r.length===0&&(n.info("No components found in your project."),process.exit(0));let f=[];for(let{fullName:i}of r){let c=await M(i,t);c.length&&f.push({name:i,changes:c})}f.length||(n.info("All components are up to date."),process.exit(0)),n.info("The following components have updates available:"),n.break();for(let i of f){n.info(`- ${l.info(i.name)}`);for(let c of i.changes)n.log(`  - ${c.filePath}`)}n.break(),n.info(`Run ${l.success("sui diff <component>")} to see the changes.`),n.info(`Run ${l.success(`sui add ${f.map(i=>i.name).join(" ")} --overwrite`)} to update the component(s).`)}function E(t){try{let e=new URL(t),o=e.pathname.split("/"),r=o.findIndex(a=>a==="r");if(r!==-1){let a=o.slice(0,r+1).join("/");return`${e.origin}${a}/index.json`}return`${e.origin}/index.json`}catch{return`${t.split("/styles/")[0]||t.split("/{")[0]}/index.json`}}async function L(t){try{let{fetchRegistry:e}=await import("./fetcher-UMK6Z5O4.js"),{registryIndexSchema:o}=await import("./schema-4HFFCHM6.js"),[r]=await e([t]);return o.parse(r)}catch{return null}}async function M(t,e){let o=await y([t],e);return!o||!o.files?[]:j(o,e)}async function W(t,e,o){let r=e.find(i=>i.name===t);r||(n.error(`The component ${l.info(t)} does not exist in the registry.`),process.exit(1)),await T(r,o)||(n.error(`The component ${l.info(t)} is not installed in your project.`),process.exit(1));let f=await J(r,o);f.length||(n.info(`No updates found for ${l.info(t)}.`),process.exit(0)),n.info(`Updates available for ${l.info(t)}:`),n.break();for(let i of f)n.info(`File: ${l.info(i.filePath)}`),n.break(),await S(i.patch),n.break()}async function B(t,e){let{registry:o,item:r}=$(t);(!o||!r)&&(n.error(`Invalid component name: ${l.info(t)}`),process.exit(1)),(!e.registries||!e.registries[o])&&(n.error(`Registry "${o}" is not configured in components.json`),process.exit(1)),await k(e,t)||(n.error(`The component ${l.info(t)} does not exist in the registry.`),process.exit(1));let f=await y([t],e);(!f||!f.files)&&(n.error(`The component ${l.info(t)} is not installed in your project.`),process.exit(1));let i=!1;for(let s of f.files){if(!s.content)continue;let m=x(s,e),g=p.basename(s.path),d=p.join(m,g);if(s.target&&(d=s.target.startsWith("~/")?p.join(e.resolvedPaths.cwd,s.target.replace("~/","")):p.join(e.resolvedPaths.cwd,s.target)),e.tsx||(d=d.replace(/\.tsx?$/,u=>u===".tsx"?".jsx":".js")),h(d)){i=!0;break}}i||(n.error(`The component ${l.info(t)} is not installed in your project.`),process.exit(1));let c=await j(f,e);c.length||(n.info(`No updates found for ${l.info(t)}.`),process.exit(0)),n.info(`Updates available for ${l.info(t)}:`),n.break();for(let s of c)n.info(`File: ${l.info(s.filePath)}`),n.break(),await S(s.patch),n.break()}function F(t,e){let o=[];if(!t.files?.length)return o;for(let r of t.files){if(typeof r=="string")continue;let a=x(r,e),f=p.basename(r.path),i=p.join(a,f);e.tsx||(i=i.replace(/\.tsx?$/,c=>c===".tsx"?".jsx":".js")),o.push(i)}return o}async function T(t,e){let o=F(t,e);for(let r of o)if(h(r))return!0;return!1}async function J(t,e){let o=await y([t.name],e);return!o||!o.files?[]:j(o,e)}async function j(t,e){if(!t||!t.files)return[];let o=[];for(let r of t.files){if(!r.content)continue;let a=x(r,e),f=p.basename(r.path),i=p.join(a,f);if(r.target&&(i=r.target.startsWith("~/")?p.join(e.resolvedPaths.cwd,r.target.replace("~/","")):p.join(e.resolvedPaths.cwd,r.target)),e.tsx||(i=i.replace(/\.tsx?$/,g=>g===".tsx"?".jsx":".js")),!h(i))continue;let c=await D.readFile(i,"utf8"),s=await A({filename:r.path,raw:r.content,config:e,transformJsx:!e.tsx},[R,v]),m=U(c,s);m.length>1&&o.push({filePath:p.relative(e.resolvedPaths.cwd,i),patch:m})}return o}async function S(t){t.forEach(e=>{if(e)return e.added?process.stdout.write(l.success(`+ ${e.value}`)):e.removed?process.stdout.write(l.error(`- ${e.value}`)):process.stdout.write(`  ${e.value}`)})}export{re as diff};
