import{a as h}from"./chunk-Y2SSMBR3.js";import{existsSync as f,readFileSync as x}from"fs";import l from"path";async function S(t){let r=l.join(t,"package.json");if(!f(r))return{isMonorepo:!1};let e=JSON.parse(x(r,"utf8")).name,a=e&&/^@[^/]+\/[^/]+/.test(e),o=t,i=0,g=5;for(;i<g;){if(f(l.join(o,"turbo.json")))return{isMonorepo:!0,root:o,packageName:e,type:"turborepo"};if(f(l.join(o,"pnpm-workspace.yaml")))return{isMonorepo:!0,root:o,packageName:e,type:"pnpm"};let p=l.join(o,"package.json");if(f(p)&&o!==t)try{let y=JSON.parse(x(p,"utf8"));if(y.workspaces)return{isMonorepo:!0,root:o,packageName:e,type:Array.isArray(y.workspaces)?"npm":"yarn"}}catch{continue}let m=l.dirname(o);if(m===o)break;o=m,i++}return a?{isMonorepo:!0,packageName:e}:{isMonorepo:!1}}function d(t){return Object.values(t).some(n=>/^@[^/]+\/[^/]+/.test(n))}import{cosmiconfig as j}from"cosmiconfig";import c from"path";import{loadConfig as O}from"tsconfig-paths";import{z as s}from"zod";import{createMatchPath as v}from"tsconfig-paths";async function k(t,r){return v(r.absoluteBaseUrl,r.paths)(t,void 0,()=>!0,[".ts",".tsx"])}var T={chakra:{name:"chakra",label:"Chakra UI"},panda:{name:"panda",label:"Panda CSS"}};var at="@/components",it="@/lib/utils",E=j("components",{searchPlaces:["components.json"]}),b=s.object({$schema:s.string().optional(),system:s.enum(Object.keys(T)).optional().default("chakra"),style:s.string().optional().default("default"),rsc:s.coerce.boolean().default(!1),tsx:s.coerce.boolean().default(!0),aliases:s.object({components:s.string(),utils:s.string(),ui:s.string().optional(),lib:s.string().optional(),hooks:s.string().optional()})}).strict(),F=b.extend({resolvedPaths:s.object({cwd:s.string(),utils:s.string(),components:s.string(),lib:s.string(),hooks:s.string(),ui:s.string()})});async function pt(t){let r=await A(t);return r?await I(t,r):null}async function I(t,r){let e=(await S(t)).isMonorepo||d(r.aliases),a=O(t);if(a.resultType==="failed")throw new Error(`Failed to load ${r.tsx?"tsconfig":"jsconfig"}.json. ${a.message??""}`.trim());let o=async i=>{if(e&&/^@[^/]+\/[^/]+/.test(i)){let p=i.match(/^@[^/]+\/[^/]+\/(.+)$/);if(p&&p[1]){let m=p[1];return c.resolve(t,"src",m)}return c.resolve(t,"src")}return await k(i,a)??c.resolve(t,"src")};return F.parse({...r,resolvedPaths:{cwd:t,utils:await o(r.aliases.utils),components:await o(r.aliases.components),ui:r.aliases.ui?await o(r.aliases.ui):c.resolve(await o(r.aliases.components),"ui"),lib:r.aliases.lib?await o(r.aliases.lib):c.resolve(await o(r.aliases.utils),".."),hooks:r.aliases.hooks?await o(r.aliases.hooks):c.resolve(await o(r.aliases.components),"..","hooks")}})}async function A(t){try{let r=await E.search(t);return r?b.parse(r.config):null}catch{let n=`${t}/components.json`;throw new Error(`Invalid configuration found in ${h.info(n)}.`)}}var w=async({sourceFile:t,config:r})=>{let n=t.getImportDeclarations();for(let e of n){let a=R(e.getModuleSpecifierValue(),r);e.setModuleSpecifier(a)}return t};function R(t,r){if(!t.startsWith("@/"))return t;if(!t.startsWith("@/registry/")){if(/^@[^/]+\/[^/]+/.test(r.aliases.components))return t;let e=r.aliases.components.charAt(0);return t.replace(/^@\//,`${e}/`)}return t.match(/^@\/registry\/(.+)\/ui/)?t.replace(/^@\/registry\/(.+)\/ui/,r.aliases.ui??`${r.aliases.components}/ui`):r.aliases.components&&t.match(/^@\/registry\/(.+)\/components/)?t.replace(/^@\/registry\/(.+)\/components/,r.aliases.components):r.aliases.lib&&t.match(/^@\/registry\/(.+)\/lib/)?t.replace(/^@\/registry\/(.+)\/lib/,r.aliases.lib):r.aliases.hooks&&t.match(/^@\/registry\/(.+)\/hooks/)?t.replace(/^@\/registry\/(.+)\/hooks/,r.aliases.hooks):t.replace(/^@\/registry\/[^/]+/,r.aliases.components)}import{SyntaxKind as J}from"ts-morph";var P=async({sourceFile:t,config:r})=>{if(r.rsc)return t;let n=t.getFirstChildByKind(J.ExpressionStatement);return n?.getText()==='"use client"'&&n.remove(),t};import{promises as N}from"fs";import{tmpdir as U}from"os";import M from"path";import{Project as Y,ScriptKind as z}from"ts-morph";import"zod";import*as u from"recast";import{transformFromAstSync as D}from"@babel/core";import{parse as $}from"@babel/parser";import L from"@babel/plugin-transform-typescript";var B={sourceType:"module",allowImportExportEverywhere:!0,allowReturnOutsideFunction:!0,startLine:1,tokens:!0,plugins:["asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","classStaticBlock","decimal","decorators-legacy","doExpressions","dynamicImport","exportDefaultFrom","exportNamespaceFrom","functionBind","functionSent","importAssertions","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{proposal:"minimal"}],["recordAndTuple",{syntaxType:"hash"}],"throwExpressions","topLevelAwait","v8intrinsic","typescript","jsx"]},C=async({sourceFile:t,config:r})=>{let n=t.getFullText();if(r.tsx)return n;let e=u.parse(n,{parser:{parse:o=>$(o,B)}}),a=D(e,n,{cloneInputAst:!1,code:!1,ast:!0,plugins:[L],configFile:!1});if(!a||!a.ast)throw new Error("Failed to transform JSX");return u.print(a.ast).code};var K=new Y({compilerOptions:{}});async function W(t){let r=await N.mkdtemp(M.join(U(),"sui-"));return M.join(r,t)}async function Ot(t,r=[w,P]){let n=await W(t.filename),e=K.createSourceFile(n,t.raw,{scriptKind:z.TSX});for(let a of r)a({sourceFile:e,...t});return t.transformJsx?await C({sourceFile:e,...t}):e.getText()}export{S as a,T as b,at as c,it as d,b as e,pt as f,I as g,w as h,P as i,Ot as j};
//# sourceMappingURL=chunk-TXDPC5OL.js.map