import{i as R,j as C}from"./chunk-SRHFU3RL.js";import{a as x,b as S,c as u,d as D,e as I,f as b,g as v,h as A,i as d,j as m,l as y,m as j}from"./chunk-AKZB7BS6.js";import{e as f,f as P,g as F,i as z}from"./chunk-FW7US4TT.js";import g from"deepmerge";import"zod";async function J(i,e){try{let s;if(e){if(!i?.registries||!i.registries[e])throw new S(e);let t=i.registries[e],o=A(t),r;typeof t=="string"?(r=t.replace("{name}","index"),r=r.replace(/\/styles\/[^/]+\//,"/"),r=x(r)):(r=t.url.replace("{name}","index"),r=r.replace(/\/styles\/[^/]+\//,"/"),r=x(r)),d({[r]:o}),s=r}else s="r/index.json";let[a]=await y([s]);return P.parse(a)}catch(s){R.error(`
`),C(s)}finally{e&&m()}}async function K(){try{let[i]=await y(["r/styles/index.json"]);return F.parse(i)}catch(i){return R.error(`
`),C(i),[]}}async function p(i,e,s={}){return await Promise.all(i.map(async t=>{if(b(t))return j(t);if(I(t)){let[c]=await y([t],s);try{return f.parse(c)}catch(n){throw new u(t,n)}}if(t.startsWith("@")&&e?.registries){let c=h([t],e),[n]=await y(c,s);try{return f.parse(n)}catch(l){throw new u(t,l)}}let o=`r/styles/${e?.style??"default"}/${t}.json`,[r]=await y([o],s);try{return f.parse(r)}catch(c){throw new u(t,c)}}))}function h(i,e){let s={},a=[...i];if(!e?.registries)return d({}),a;for(let t=0;t<a.length;t++){let o=a[t];if(!o)continue;let r=v(o,e);r?.url&&(a[t]=r.url,Object.keys(r.headers).length>0&&(s[r.url]=r.headers))}return d(s),a}async function M(i,e,s={}){s={useCache:!0,...s},m();let a=[],t=Array.from(new Set(i)),o=await p(t,e,s);for(let n=0;n<o.length;n++){let l=o[n];if(l&&(a.push(l),l.registryDependencies)){let E=await w(l.registryDependencies,e,s,new Set(t));a.push(...E)}}if(!a.length)return null;let r="";return a.forEach(n=>{n.docs&&(r+=`${n.docs}
`)}),z.parse({dependencies:g.all(a.map(n=>n.dependencies??[])),devDependencies:g.all(a.map(n=>n.devDependencies??[])),files:g.all(a.map(n=>n.files??[])),tailwind:a.reduce((n,l)=>g(n,l.tailwind??{}),{}),cssVars:a.reduce((n,l)=>g(n,l.cssVars??{}),{}),docs:r})}async function w(i,e,s={},a=new Set){let t=[];for(let o of i)if(!a.has(o))if(a.add(o),I(o)||b(o)){let[r]=await p([o],e,s);if(r&&(t.push(r),r.registryDependencies)){let c=e?.registries?h(r.registryDependencies,e):r.registryDependencies,n=await w(c,e,s,a);t.push(...n)}}else if(o.startsWith("@")&&e?.registries){let{registry:r}=D(o);if(r&&!(r in e.registries))throw new S(r);let[c]=await p([o],e,s);if(c&&(t.push(c),c.registryDependencies)){let n=e?.registries?h(c.registryDependencies,e):c.registryDependencies,l=await w(n,e,s,a);t.push(...l)}}else try{let[r]=await p([o],e,s);if(r&&r.registryDependencies){let c=e?.registries?h(r.registryDependencies,e):r.registryDependencies,n=await w(c,e,s,a);t.push(...n)}}catch{continue}return t}async function Q(i,e){let[s]=await p([e],i);return s}function X(i,e,s){return s||(i.type==="registry:ui"?e.resolvedPaths.ui:i.type==="registry:lib"?e.resolvedPaths.lib:i.type==="registry:block"||i.type==="registry:component"?e.resolvedPaths.components:i.type==="registry:hook"?e.resolvedPaths.hooks:(i.type==="registry:page",e.resolvedPaths.components))}export{J as a,K as b,M as c,Q as d,X as e};
//# sourceMappingURL=chunk-BNBIDCWF.js.map