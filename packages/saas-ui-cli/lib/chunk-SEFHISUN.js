import{a as h,e as w}from"./chunk-L36FRG6H.js";import{cyan as P,green as R,red as $,yellow as C}from"kleur/colors";var c={error:$,warn:C,info:P,success:R};var s={error(...r){console.log(c.error(r.join(" ")))},warn(...r){console.log(c.warn(r.join(" ")))},info(...r){console.log(c.info(r.join(" ")))},success(...r){console.log(c.success(r.join(" ")))},debug(...r){process.env.DEBUG&&console.log(r.join(" "))},log(...r){console.log(r.join(" "))},break(){console.log("")}};import{z}from"zod";function u(r){if(s.error("Something went wrong. Please check the error below for more details."),s.error("If the problem persists, please open an issue on GitHub."),s.error(""),typeof r=="string"&&(s.error(r),s.break(),process.exit(1)),r instanceof z.ZodError){s.error("Validation failed:");for(let[t,i]of Object.entries(r.flatten().fieldErrors))s.error(`- ${c.info(t)}: ${i}`);s.break(),process.exit(1)}r instanceof Error&&(s.error(r.message),s.break(),process.exit(1)),s.break(),process.exit(1)}import{z as e}from"zod";var x=e.enum(["registry:style","registry:lib","registry:example","registry:block","registry:component","registry:ui","registry:hook","registry:theme","registry:page","registry:icon","registry:story"]),b=e.object({path:e.string(),content:e.string().optional(),type:x,target:e.string().optional()}),D=e.object({config:e.object({content:e.array(e.string()).optional(),theme:e.record(e.string(),e.any()).optional(),plugins:e.array(e.string()).optional()}).optional()}),T=e.object({light:e.record(e.string(),e.string()).optional(),dark:e.record(e.string(),e.string()).optional()}),m=e.object({name:e.string(),type:x,private:e.boolean().optional(),description:e.string().optional(),dependencies:e.array(e.string()).optional(),devDependencies:e.array(e.string()).optional(),registryDependencies:e.array(e.string()).optional(),files:e.array(b).optional(),tailwind:D.optional(),cssVars:T.optional(),meta:e.record(e.string(),e.any()).optional(),docs:e.string().optional(),category:e.string().optional(),subcategory:e.string().optional()}),k=e.array(m.extend({files:e.array(e.union([e.string(),b])).optional()})),v=e.array(e.object({name:e.string(),label:e.string()})),E=e.object({inlineColors:e.object({light:e.record(e.string(),e.string()),dark:e.record(e.string(),e.string())}),cssVars:e.object({light:e.record(e.string(),e.string()),dark:e.record(e.string(),e.string())}),inlineColorsTemplate:e.string(),cssVarsTemplate:e.string()}),I=m.pick({dependencies:!0,devDependencies:!0,files:!0,tailwind:!0,cssVars:!0,docs:!0});import d from"deepmerge";import{HttpsProxyAgent as B}from"https-proxy-agent";import V from"node-fetch";import ee from"path";import{z as F}from"zod";var G=process.env.https_proxy?new B(process.env.https_proxy):void 0;async function A(){try{let[r]=await f(["index.json"]);return k.parse(r)}catch(r){s.error(`
`),u(r)}}async function le(){try{let[r]=await f(["styles/index.json"]);return v.parse(r)}catch(r){return s.error(`
`),u(r),[]}}async function f(r){try{let t=await w(),i=new Headers;return t?.token&&i.set("Authorization",`Bearer ${t.token}`),await Promise.all(r.map(async p=>{let a=S(p),n=await V(a,{agent:G,headers:i});if(!n.ok){let l={400:"Bad request",401:"Unauthorized",403:"Forbidden",404:"Not found",500:"Internal server error"};if(n.status===401)throw new Error(`You are not authorized to access the component at ${c.info(a)}.
If this is a remote registry, you may need to authenticate.`);if(n.status===404)throw new Error(`The component at ${c.info(a)} was not found.
It may not exist at the registry. Please make sure it is a valid component.`);if(n.status===403)throw new Error(`You do not have access to the component at ${c.info(a)}.
If this is a remote registry, you may need to authenticate or a token.`);let o=await n.json(),y=o&&typeof o=="object"&&"error"in o?o.error:n.statusText||l[n.status];throw new Error(`Failed to fetch from ${c.info(a)}.
${y}`)}return n.json()}))}catch(t){return s.error(`
`),u(t),[]}}function ge(r,t,i){return i||(r.type==="registry:ui"?t.resolvedPaths.ui:r.type==="registry:lib"?t.resolvedPaths.lib:r.type==="registry:block"||r.type==="registry:component"?t.resolvedPaths.components:r.type==="registry:hook"?t.resolvedPaths.hooks:r.type==="registry:page"?t.resolvedPaths.components:r.type==="registry:icon"?t.resolvedPaths.icons:t.resolvedPaths.components)}async function pe(r,t){try{if(!await A())return null;r.includes("index")&&r.unshift("index");let g=[];for(let o of r){let y=await U(o,t);g.push(...y)}let p=Array.from(new Set(g)),a=await f(p),n=F.array(m).parse(a);if(!n)return null;let l="";return n.forEach(o=>{o.docs&&(l+=`${o.docs}
`)}),I.parse({dependencies:d.all(n.map(o=>o.dependencies??[])),devDependencies:d.all(n.map(o=>o.devDependencies??[])),files:d.all(n.map(o=>o.files??[])),docs:l})}catch(i){return u(i),null}}async function U(r,t){let i=new Set,g=[];async function p(a){let n=S(j(a)?a:`styles/${t.style}/${a}.json`);if(!i.has(n)){i.add(n);try{let[l]=await f([n]),o=m.parse(l);if(g.push(n),o.registryDependencies)for(let y of o.registryDependencies)await p(y)}catch(l){console.error(`Error fetching or parsing registry item at ${a}:`,l)}}}return await p(r),Array.from(new Set(g))}function S(r){if(j(r)){let t=new URL(r);return t.pathname.match(/\/chat\/b\//)&&!t.pathname.endsWith("/json")&&(t.pathname=`${t.pathname}/json`),t.toString()}return`${h}/${r}`}function j(r){try{return new URL(r),!0}catch{return!1}}export{c as a,s as b,u as c,A as d,le as e,ge as f,pe as g};
//# sourceMappingURL=chunk-SEFHISUN.js.map