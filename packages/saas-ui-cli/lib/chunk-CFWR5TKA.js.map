{"version":3,"sources":["../src/utils/transformers/transform-import.ts","../src/utils/transformers/transform-rsc.ts","../src/utils/transformers/index.ts","../src/utils/transformers/transform-jsx.ts"],"sourcesContent":["import type { Config } from '#utils/get-config'\nimport type { Transformer } from '#utils/transformers'\n\nexport const transformImport: Transformer = async ({ sourceFile, config }) => {\n  const importDeclarations = sourceFile.getImportDeclarations()\n\n  for (const importDeclaration of importDeclarations) {\n    const moduleSpecifier = updateImportAliases(\n      importDeclaration.getModuleSpecifierValue(),\n      config,\n    )\n\n    importDeclaration.setModuleSpecifier(moduleSpecifier)\n  }\n\n  return sourceFile\n}\n\nfunction updateImportAliases(moduleSpecifier: string, config: Config) {\n  // Not a local import.\n  if (!moduleSpecifier.startsWith('@/')) {\n    return moduleSpecifier\n  }\n\n  // Not a registry import.\n  if (!moduleSpecifier.startsWith('@/registry/')) {\n    const isMonorepoConfig = /^@[^/]+\\/[^/]+/.test(config.aliases.components)\n    if (isMonorepoConfig) {\n      return moduleSpecifier\n    }\n\n    const alias = config.aliases.components.charAt(0)\n    return moduleSpecifier.replace(/^@\\//, `${alias}/`)\n  }\n\n  if (moduleSpecifier.match(/^@\\/registry\\/(.+)\\/ui/)) {\n    return moduleSpecifier.replace(\n      /^@\\/registry\\/(.+)\\/ui/,\n      config.aliases.ui ?? `${config.aliases.components}/ui`,\n    )\n  }\n\n  if (\n    config.aliases.components &&\n    moduleSpecifier.match(/^@\\/registry\\/(.+)\\/components/)\n  ) {\n    return moduleSpecifier.replace(\n      /^@\\/registry\\/(.+)\\/components/,\n      config.aliases.components,\n    )\n  }\n\n  if (config.aliases.lib && moduleSpecifier.match(/^@\\/registry\\/(.+)\\/lib/)) {\n    return moduleSpecifier.replace(\n      /^@\\/registry\\/(.+)\\/lib/,\n      config.aliases.lib,\n    )\n  }\n\n  if (\n    config.aliases.hooks &&\n    moduleSpecifier.match(/^@\\/registry\\/(.+)\\/hooks/)\n  ) {\n    return moduleSpecifier.replace(\n      /^@\\/registry\\/(.+)\\/hooks/,\n      config.aliases.hooks,\n    )\n  }\n\n  return moduleSpecifier.replace(\n    /^@\\/registry\\/[^/]+/,\n    config.aliases.components,\n  )\n}\n","import { SyntaxKind } from 'ts-morph'\r\n\r\nimport type { Transformer } from '#utils/transformers'\r\n\r\nexport const transformRsc: Transformer = async ({ sourceFile, config }) => {\r\n  if (config.rsc) {\r\n    return sourceFile\r\n  }\r\n\r\n  // Remove \"use client\" from the top of the file.\r\n  const first = sourceFile.getFirstChildByKind(SyntaxKind.ExpressionStatement)\r\n  if (first?.getText() === `\"use client\"`) {\r\n    first.remove()\r\n  }\r\n\r\n  return sourceFile\r\n}\r\n","import { promises as fs } from 'node:fs'\r\nimport { tmpdir } from 'node:os'\r\nimport path from 'node:path'\r\nimport { Project, ScriptKind, type SourceFile } from 'ts-morph'\r\nimport { z } from 'zod'\r\n\r\nimport type { Config } from '#utils/get-config'\r\nimport { registryBaseColorSchema } from '#utils/registry/schema'\r\nimport { transformImport } from '#utils/transformers/transform-import'\r\nimport { transformJsx } from '#utils/transformers/transform-jsx'\r\nimport { transformRsc } from '#utils/transformers/transform-rsc'\r\n\r\nexport type TransformOpts = {\r\n  filename: string\r\n  raw: string\r\n  config: Config\r\n  baseColor?: z.infer<typeof registryBaseColorSchema>\r\n  transformJsx?: boolean\r\n}\r\n\r\nexport type Transformer<Output = SourceFile> = (\r\n  opts: TransformOpts & {\r\n    sourceFile: SourceFile\r\n  },\r\n) => Promise<Output>\r\n\r\nconst project = new Project({\r\n  compilerOptions: {},\r\n})\r\n\r\nasync function createTempSourceFile(filename: string) {\r\n  const dir = await fs.mkdtemp(path.join(tmpdir(), 'sui-'))\r\n  return path.join(dir, filename)\r\n}\r\n\r\nexport async function transform(\r\n  opts: TransformOpts,\r\n  transformers: Transformer[] = [transformImport, transformRsc],\r\n) {\r\n  const tempFile = await createTempSourceFile(opts.filename)\r\n  const sourceFile = project.createSourceFile(tempFile, opts.raw, {\r\n    scriptKind: ScriptKind.TSX,\r\n  })\r\n\r\n  for (const transformer of transformers) {\r\n    transformer({ sourceFile, ...opts })\r\n  }\r\n\r\n  if (opts.transformJsx) {\r\n    return await transformJsx({\r\n      sourceFile,\r\n      ...opts,\r\n    })\r\n  }\r\n\r\n  return sourceFile.getText()\r\n}\r\n","import * as recast from 'recast'\r\nimport { transformFromAstSync } from '@babel/core'\r\nimport { type ParserOptions, parse } from '@babel/parser'\r\n// @ts-ignore\r\nimport transformTypescript from '@babel/plugin-transform-typescript'\r\n\r\nimport { type Transformer } from '#utils/transformers'\r\n\r\n// TODO.\r\n// I'm using recast for the AST here.\r\n// Figure out if ts-morph AST is compatible with Babel.\r\n\r\n// This is a copy of the babel options from recast/parser.\r\n// The goal here is to tolerate as much syntax as possible.\r\n// We want to be able to parse any valid tsx code.\r\n// See https://github.com/benjamn/recast/blob/master/parsers/_babel_options.ts.\r\nconst PARSE_OPTIONS: ParserOptions = {\r\n  sourceType: 'module',\r\n  allowImportExportEverywhere: true,\r\n  allowReturnOutsideFunction: true,\r\n  startLine: 1,\r\n  tokens: true,\r\n  plugins: [\r\n    'asyncGenerators',\r\n    'bigInt',\r\n    'classPrivateMethods',\r\n    'classPrivateProperties',\r\n    'classProperties',\r\n    'classStaticBlock',\r\n    'decimal',\r\n    'decorators-legacy',\r\n    'doExpressions',\r\n    'dynamicImport',\r\n    'exportDefaultFrom',\r\n    'exportNamespaceFrom',\r\n    'functionBind',\r\n    'functionSent',\r\n    'importAssertions',\r\n    'importMeta',\r\n    'nullishCoalescingOperator',\r\n    'numericSeparator',\r\n    'objectRestSpread',\r\n    'optionalCatchBinding',\r\n    'optionalChaining',\r\n    [\r\n      'pipelineOperator',\r\n      {\r\n        proposal: 'minimal',\r\n      },\r\n    ],\r\n    [\r\n      'recordAndTuple',\r\n      {\r\n        syntaxType: 'hash',\r\n      },\r\n    ],\r\n    'throwExpressions',\r\n    'topLevelAwait',\r\n    'v8intrinsic',\r\n    'typescript',\r\n    'jsx',\r\n  ],\r\n}\r\n\r\nexport const transformJsx: Transformer<string> = async ({\r\n  sourceFile,\r\n  config,\r\n}) => {\r\n  const output = sourceFile.getFullText()\r\n\r\n  if (config.tsx) {\r\n    return output\r\n  }\r\n\r\n  const ast = recast.parse(output, {\r\n    parser: {\r\n      parse: (code: string) => {\r\n        return parse(code, PARSE_OPTIONS)\r\n      },\r\n    },\r\n  })\r\n\r\n  const result = transformFromAstSync(ast, output, {\r\n    cloneInputAst: false,\r\n    code: false,\r\n    ast: true,\r\n    plugins: [transformTypescript],\r\n    configFile: false,\r\n  })\r\n\r\n  if (!result || !result.ast) {\r\n    throw new Error('Failed to transform JSX')\r\n  }\r\n\r\n  return recast.print(result.ast).code\r\n}\r\n"],"mappings":"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","names":["transformImport","sourceFile","config","importDeclarations","importDeclaration","moduleSpecifier","updateImportAliases","alias","SyntaxKind","transformRsc","sourceFile","config","first","fs","tmpdir","path","Project","ScriptKind","recast","transformFromAstSync","parse","transformTypescript","PARSE_OPTIONS","transformJsx","sourceFile","config","output","ast","code","parse","result","transformFromAstSync","transformTypescript","project","Project","createTempSourceFile","filename","dir","fs","path","tmpdir","transform","opts","transformers","transformImport","transformRsc","tempFile","sourceFile","ScriptKind","transformer","transformJsx"]}