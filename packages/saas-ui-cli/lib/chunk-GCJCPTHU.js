import{a as h}from"./chunk-SEFHISUN.js";import{existsSync as u,readFileSync as x}from"fs";import l from"path";async function S(t){let r=l.join(t,"package.json");if(!u(r))return{isMonorepo:!1};let e=JSON.parse(x(r,"utf8")).name,a=e&&/^@[^/]+\/[^/]+/.test(e),s=t,p=0,g=5;for(;p<g;){if(u(l.join(s,"turbo.json")))return{isMonorepo:!0,root:s,packageName:e,type:"turborepo"};if(u(l.join(s,"pnpm-workspace.yaml")))return{isMonorepo:!0,root:s,packageName:e,type:"pnpm"};let c=l.join(s,"package.json");if(u(c)&&s!==t)try{let y=JSON.parse(x(c,"utf8"));if(y.workspaces)return{isMonorepo:!0,root:s,packageName:e,type:Array.isArray(y.workspaces)?"npm":"yarn"}}catch{continue}let m=l.dirname(s);if(m===s)break;s=m,p++}return a?{isMonorepo:!0,packageName:e}:{isMonorepo:!1}}function d(t){return Object.values(t).some(n=>/^@[^/]+\/[^/]+/.test(n))}import{cosmiconfig as j}from"cosmiconfig";import i from"path";import{loadConfig as O}from"tsconfig-paths";import{z as o}from"zod";import{createMatchPath as M}from"tsconfig-paths";async function k(t,r){return M(r.absoluteBaseUrl,r.paths)(t,void 0,()=>!0,[".ts",".tsx"])}var w={chakra:{name:"chakra",label:"Chakra UI"},panda:{name:"panda",label:"Panda CSS"}};var at="@/components",it="@/lib/utils",E=j("components",{searchPlaces:["components.json"]}),T=o.object({$schema:o.string().optional(),system:o.enum(Object.keys(w)).optional().default("chakra"),style:o.string().optional().default("default"),rsc:o.coerce.boolean().default(!1),tsx:o.coerce.boolean().default(!0),aliases:o.object({components:o.string(),utils:o.string(),ui:o.string().optional(),lib:o.string().optional(),hooks:o.string().optional(),icons:o.string().optional()}),icons:o.object({outputDir:o.string().optional(),defaultIconSet:o.string().optional(),iconSize:o.string().optional(),aliases:o.record(o.string()).optional()}).optional()}).strict(),I=T.extend({resolvedPaths:o.object({cwd:o.string(),utils:o.string(),components:o.string(),lib:o.string(),hooks:o.string(),ui:o.string(),icons:o.string()})});async function pt(t){let r=await A(t);return r?await F(t,r):null}async function F(t,r){let e=(await S(t)).isMonorepo||d(r.aliases),a=O(t);if(a.resultType==="failed")throw new Error(`Failed to load ${r.tsx?"tsconfig":"jsconfig"}.json. ${a.message??""}`.trim());let s=async p=>{if(e&&/^@[^/]+\/[^/]+/.test(p)){let c=p.match(/^@[^/]+\/[^/]+\/(.+)$/);if(c&&c[1]){let m=c[1];return i.resolve(t,"src",m)}return i.resolve(t,"src")}return await k(p,a)??i.resolve(t,"src")};return I.parse({...r,resolvedPaths:{cwd:t,utils:await s(r.aliases.utils),components:await s(r.aliases.components),ui:r.aliases.ui?await s(r.aliases.ui):i.resolve(await s(r.aliases.components),"ui"),lib:r.aliases.lib?await s(r.aliases.lib):i.resolve(await s(r.aliases.utils),".."),hooks:r.aliases.hooks?await s(r.aliases.hooks):i.resolve(await s(r.aliases.components),"..","hooks"),icons:r.aliases.icons?await s(r.aliases.icons):i.resolve(await s(r.aliases.components),"icons")}})}async function A(t){try{let r=await E.search(t);return r?T.parse(r.config):null}catch{let n=`${t}/components.json`;throw new Error(`Invalid configuration found in ${h.info(n)}.`)}}var b=async({sourceFile:t,config:r})=>{let n=t.getImportDeclarations();for(let e of n){let a=R(e.getModuleSpecifierValue(),r);e.setModuleSpecifier(a)}return t};function R(t,r){if(!t.startsWith("@/")&&!t.startsWith("#"))return t;if(!t.startsWith("@/registry/")&&!t.startsWith("#registry/")){if(/^@[^/]+\/[^/]+/.test(r.aliases.components))return t;let e=r.aliases.components.charAt(0);return t.replace(/^@\//,`${e}/`)}return t.match(/^(@\/|#)registry\/(.+)\/ui/)?t.replace(/^(@\/|#)registry\/(.+)\/ui/,r.aliases.ui??`${r.aliases.components}/ui`):r.aliases.components&&t.match(/^(@\/|#)registry\/(.+)\/components/)?t.replace(/^(@\/|#)registry\/(.+)\/components/,r.aliases.components):r.aliases.lib&&t.match(/^@\/registry\/(.+)\/lib/)?t.replace(/^@\/registry\/(.+)\/lib/,r.aliases.lib):r.aliases.hooks&&t.match(/^(@\/|#)registry\/(.+)\/hooks/)?t.replace(/^(@\/|#)registry\/(.+)\/hooks/,r.aliases.hooks):r.aliases.icons&&t.match(/^(@\/|#)registry\/(.+)\/icons/)?t.replace(/^(@\/|#)registry\/(.+)\/icons/,r.aliases.icons):t.replace(/^@\/registry\/[^/]+/,r.aliases.components)}import{SyntaxKind as J}from"ts-morph";var P=async({sourceFile:t,config:r})=>{if(r.rsc)return t;let n=t.getFirstChildByKind(J.ExpressionStatement);return n?.getText()==='"use client"'&&n.remove(),t};import{promises as N}from"fs";import{tmpdir as U}from"os";import C from"path";import{Project as z,ScriptKind as W}from"ts-morph";import"zod";import*as f from"recast";import{transformFromAstSync as D}from"@babel/core";import{parse as $}from"@babel/parser";import L from"@babel/plugin-transform-typescript";var B={sourceType:"module",allowImportExportEverywhere:!0,allowReturnOutsideFunction:!0,startLine:1,tokens:!0,plugins:["asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","classStaticBlock","decimal","decorators-legacy","doExpressions","dynamicImport","exportDefaultFrom","exportNamespaceFrom","functionBind","functionSent","importAssertions","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{proposal:"minimal"}],["recordAndTuple",{syntaxType:"hash"}],"throwExpressions","topLevelAwait","v8intrinsic","typescript","jsx"]},v=async({sourceFile:t,config:r})=>{let n=t.getFullText();if(r.tsx)return n;let e=f.parse(n,{parser:{parse:s=>$(s,B)}}),a=D(e,n,{cloneInputAst:!1,code:!1,ast:!0,plugins:[L],configFile:!1});if(!a||!a.ast)throw new Error("Failed to transform JSX");return f.print(a.ast).code};var Y=new z({compilerOptions:{}});async function K(t){let r=await N.mkdtemp(C.join(U(),"sui-"));return C.join(r,t)}async function Ot(t,r=[b,P]){let n=await K(t.filename),e=Y.createSourceFile(n,t.raw,{scriptKind:W.TSX});for(let a of r)a({sourceFile:e,...t});return t.transformJsx?await v({sourceFile:e,...t}):e.getText()}export{S as a,w as b,at as c,it as d,T as e,pt as f,F as g,b as h,P as i,Ot as j};
//# sourceMappingURL=chunk-GCJCPTHU.js.map