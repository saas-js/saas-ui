{"version":3,"sources":["../src/utils/highlighter.ts","../src/utils/logger.ts","../src/utils/handle-error.ts","../src/utils/registry/schema.ts","../src/utils/registry/index.ts"],"sourcesContent":["import { cyan, green, red, yellow } from 'kleur/colors'\n\nexport const highlighter = {\n  error: red,\n  warn: yellow,\n  info: cyan,\n  success: green,\n}\n","import { highlighter } from '#utils/highlighter'\n\nexport const logger = {\n  error(...args: unknown[]) {\n    console.log(highlighter.error(args.join(' ')))\n  },\n  warn(...args: unknown[]) {\n    console.log(highlighter.warn(args.join(' ')))\n  },\n  info(...args: unknown[]) {\n    console.log(highlighter.info(args.join(' ')))\n  },\n  success(...args: unknown[]) {\n    console.log(highlighter.success(args.join(' ')))\n  },\n  debug(...args: unknown[]) {\n    if (process.env.DEBUG) {\n      console.log(args.join(' '))\n    }\n  },\n  log(...args: unknown[]) {\n    console.log(args.join(' '))\n  },\n  break() {\n    console.log('')\n  },\n}\n","import { z } from 'zod'\n\nimport { highlighter } from '#utils/highlighter'\nimport { logger } from '#utils/logger'\n\nexport function handleError(error: unknown) {\n  logger.error(\n    `Something went wrong. Please check the error below for more details.`,\n  )\n  logger.error(`If the problem persists, please open an issue on GitHub.`)\n  logger.error('')\n  if (typeof error === 'string') {\n    logger.error(error)\n    logger.break()\n    process.exit(1)\n  }\n\n  if (error instanceof z.ZodError) {\n    logger.error('Validation failed:')\n    for (const [key, value] of Object.entries(error.flatten().fieldErrors)) {\n      logger.error(`- ${highlighter.info(key)}: ${value}`)\n    }\n    logger.break()\n    process.exit(1)\n  }\n\n  if (error instanceof Error) {\n    logger.error(error.message)\n    logger.break()\n    process.exit(1)\n  }\n\n  logger.break()\n  process.exit(1)\n}\n","import { z } from 'zod'\n\n// TODO: Extract this to a shared package.\nexport const registryItemTypeSchema = z.enum([\n  'registry:style',\n  'registry:lib',\n  'registry:example',\n  'registry:block',\n  'registry:component',\n  'registry:ui',\n  'registry:hook',\n  'registry:theme',\n  'registry:page',\n  'registry:story',\n])\n\nexport const registryItemFileSchema = z.object({\n  path: z.string(),\n  content: z.string().optional(),\n  type: registryItemTypeSchema,\n  target: z.string().optional(),\n})\n\nexport const registryItemTailwindSchema = z.object({\n  config: z\n    .object({\n      content: z.array(z.string()).optional(),\n      theme: z.record(z.string(), z.any()).optional(),\n      plugins: z.array(z.string()).optional(),\n    })\n    .optional(),\n})\n\nexport const registryItemCssVarsSchema = z.object({\n  light: z.record(z.string(), z.string()).optional(),\n  dark: z.record(z.string(), z.string()).optional(),\n})\n\nexport const registryItemSchema = z.object({\n  name: z.string(),\n  type: registryItemTypeSchema,\n  private: z.boolean().optional(),\n  description: z.string().optional(),\n  dependencies: z.array(z.string()).optional(),\n  devDependencies: z.array(z.string()).optional(),\n  registryDependencies: z.array(z.string()).optional(),\n  files: z.array(registryItemFileSchema).optional(),\n  tailwind: registryItemTailwindSchema.optional(),\n  cssVars: registryItemCssVarsSchema.optional(),\n  meta: z.record(z.string(), z.any()).optional(),\n  docs: z.string().optional(),\n  category: z.string().optional(),\n  subcategory: z.string().optional(),\n})\n\nexport type RegistryItem = z.infer<typeof registryItemSchema>\n\nexport const registryIndexSchema = z.array(\n  registryItemSchema.extend({\n    files: z.array(z.union([z.string(), registryItemFileSchema])).optional(),\n  }),\n)\n\nexport const stylesSchema = z.array(\n  z.object({\n    name: z.string(),\n    label: z.string(),\n  }),\n)\n\nexport const registryBaseColorSchema = z.object({\n  inlineColors: z.object({\n    light: z.record(z.string(), z.string()),\n    dark: z.record(z.string(), z.string()),\n  }),\n  cssVars: z.object({\n    light: z.record(z.string(), z.string()),\n    dark: z.record(z.string(), z.string()),\n  }),\n  inlineColorsTemplate: z.string(),\n  cssVarsTemplate: z.string(),\n})\n\nexport const registryResolvedItemsTreeSchema = registryItemSchema.pick({\n  dependencies: true,\n  devDependencies: true,\n  files: true,\n  tailwind: true,\n  cssVars: true,\n  docs: true,\n})\n","import deepmerge from 'deepmerge'\nimport { HttpsProxyAgent } from 'https-proxy-agent'\nimport fetch from 'node-fetch'\nimport path from 'node:path'\nimport { z } from 'zod'\n\nimport { REGISTRY_URL } from '#constants'\nimport { readConfig } from '#utils/auth'\nimport type { Config } from '#utils/get-config'\nimport { handleError } from '#utils/handle-error'\nimport { highlighter } from '#utils/highlighter'\nimport { logger } from '#utils/logger'\nimport {\n  registryBaseColorSchema,\n  registryIndexSchema,\n  registryItemFileSchema,\n  registryItemSchema,\n  registryResolvedItemsTreeSchema,\n  stylesSchema,\n} from '#utils/registry/schema'\n\nconst agent = process.env.https_proxy\n  ? new HttpsProxyAgent(process.env.https_proxy)\n  : undefined\n\nexport async function getRegistryIndex() {\n  try {\n    const [result] = await fetchRegistry(['index.json'])\n\n    return registryIndexSchema.parse(result)\n  } catch (error) {\n    logger.error('\\n')\n    handleError(error)\n  }\n}\n\nexport async function getRegistryStyles() {\n  try {\n    const [result] = await fetchRegistry(['styles/index.json'])\n\n    return stylesSchema.parse(result)\n  } catch (error) {\n    logger.error('\\n')\n    handleError(error)\n    return []\n  }\n}\n\nexport async function getRegistryItem(name: string, style: string) {\n  try {\n    const [result] = await fetchRegistry([\n      isUrl(name) ? name : `styles/${style}/${name}.json`,\n    ])\n\n    return registryItemSchema.parse(result)\n  } catch (error) {\n    logger.break()\n    handleError(error)\n    return null\n  }\n}\n\nexport async function getRegistryBaseColors() {\n  return [\n    {\n      name: 'neutral',\n      label: 'Neutral',\n    },\n    {\n      name: 'gray',\n      label: 'Gray',\n    },\n    {\n      name: 'zinc',\n      label: 'Zinc',\n    },\n    {\n      name: 'stone',\n      label: 'Stone',\n    },\n    {\n      name: 'slate',\n      label: 'Slate',\n    },\n  ]\n}\n\nexport async function getRegistryBaseColor(baseColor: string) {\n  try {\n    const [result] = await fetchRegistry([`colors/${baseColor}.json`])\n\n    return registryBaseColorSchema.parse(result)\n  } catch (error) {\n    handleError(error)\n  }\n}\n\nexport async function resolveTree(\n  index: z.infer<typeof registryIndexSchema>,\n  names: string[],\n) {\n  const tree: z.infer<typeof registryIndexSchema> = []\n\n  for (const name of names) {\n    const entry = index.find((entry) => entry.name === name)\n\n    if (!entry) {\n      continue\n    }\n\n    tree.push(entry)\n\n    if (entry.registryDependencies) {\n      const dependencies = await resolveTree(index, entry.registryDependencies)\n      tree.push(...dependencies)\n    }\n  }\n\n  return tree.filter(\n    (component, index, self) =>\n      self.findIndex((c) => c.name === component.name) === index,\n  )\n}\n\nexport async function fetchTree(\n  style: string,\n  tree: z.infer<typeof registryIndexSchema>,\n) {\n  try {\n    const paths = tree.map((item) => `styles/${style}/${item.name}.json`)\n    const result = await fetchRegistry(paths)\n    return registryIndexSchema.parse(result)\n  } catch (error) {\n    handleError(error)\n  }\n}\n\nexport async function getItemTargetPath(\n  config: Config,\n  item: Pick<z.infer<typeof registryItemSchema>, 'type'>,\n  override?: string,\n) {\n  if (override) {\n    return override\n  }\n\n  if (item.type === 'registry:ui') {\n    return config.resolvedPaths.ui ?? config.resolvedPaths.components\n  }\n\n  const [parent, type] = item.type.split(':')\n  if (!parent || !(parent in config.resolvedPaths)) {\n    return null\n  }\n\n  if (!type) {\n    return null\n  }\n\n  return path.join(\n    config.resolvedPaths[parent as keyof typeof config.resolvedPaths],\n    type,\n  )\n}\n\nasync function fetchRegistry(paths: string[]) {\n  try {\n    const config = await readConfig()\n\n    const headers = new Headers()\n\n    if (config?.token) {\n      headers.set('Authorization', `Bearer ${config.token}`)\n    }\n\n    const results = await Promise.all(\n      paths.map(async (path) => {\n        const url = getRegistryUrl(path)\n        const response = await fetch(url, { agent, headers })\n\n        if (!response.ok) {\n          const errorMessages: { [key: number]: string } = {\n            400: 'Bad request',\n            401: 'Unauthorized',\n            403: 'Forbidden',\n            404: 'Not found',\n            500: 'Internal server error',\n          }\n\n          if (response.status === 401) {\n            throw new Error(\n              `You are not authorized to access the component at ${highlighter.info(\n                url,\n              )}.\\nIf this is a remote registry, you may need to authenticate.`,\n            )\n          }\n\n          if (response.status === 404) {\n            throw new Error(\n              `The component at ${highlighter.info(\n                url,\n              )} was not found.\\nIt may not exist at the registry. Please make sure it is a valid component.`,\n            )\n          }\n\n          if (response.status === 403) {\n            throw new Error(\n              `You do not have access to the component at ${highlighter.info(\n                url,\n              )}.\\nIf this is a remote registry, you may need to authenticate or a token.`,\n            )\n          }\n\n          const result = await response.json()\n          const message =\n            result && typeof result === 'object' && 'error' in result\n              ? result.error\n              : response.statusText || errorMessages[response.status]\n          throw new Error(\n            `Failed to fetch from ${highlighter.info(url)}.\\n${message}`,\n          )\n        }\n\n        return response.json()\n      }),\n    )\n\n    return results\n  } catch (error) {\n    logger.error('\\n')\n    handleError(error)\n    return []\n  }\n}\n\nexport function getRegistryItemFileTargetPath(\n  file: z.infer<typeof registryItemFileSchema>,\n  config: Config,\n  override?: string,\n) {\n  if (override) {\n    return override\n  }\n\n  if (file.type === 'registry:ui') {\n    return config.resolvedPaths.ui\n  }\n\n  if (file.type === 'registry:lib') {\n    return config.resolvedPaths.lib\n  }\n\n  if (file.type === 'registry:block' || file.type === 'registry:component') {\n    return config.resolvedPaths.components\n  }\n\n  if (file.type === 'registry:hook') {\n    return config.resolvedPaths.hooks\n  }\n\n  // TODO: we put this in components for now.\n  // We should move this to pages as per framework.\n  if (file.type === 'registry:page') {\n    return config.resolvedPaths.components\n  }\n\n  return config.resolvedPaths.components\n}\n\nexport async function registryResolveItemsTree(\n  names: z.infer<typeof registryItemSchema>['name'][],\n  config: Config,\n) {\n  try {\n    const index = await getRegistryIndex()\n    if (!index) {\n      return null\n    }\n\n    // If we're resolving the index, we want it to go first.\n    if (names.includes('index')) {\n      names.unshift('index')\n    }\n\n    const registryDependencies: string[] = []\n    for (const name of names) {\n      const itemRegistryDependencies = await resolveRegistryDependencies(\n        name,\n        config,\n      )\n      registryDependencies.push(...itemRegistryDependencies)\n    }\n\n    const uniqueRegistryDependencies = Array.from(new Set(registryDependencies))\n    const result = await fetchRegistry(uniqueRegistryDependencies)\n    const payload = z.array(registryItemSchema).parse(result)\n\n    if (!payload) {\n      return null\n    }\n\n    let docs = ''\n    payload.forEach((item) => {\n      if (item.docs) {\n        docs += `${item.docs}\\n`\n      }\n    })\n\n    return registryResolvedItemsTreeSchema.parse({\n      dependencies: deepmerge.all(\n        payload.map((item) => item.dependencies ?? []),\n      ),\n      devDependencies: deepmerge.all(\n        payload.map((item) => item.devDependencies ?? []),\n      ),\n      files: deepmerge.all(payload.map((item) => item.files ?? [])),\n      docs,\n    })\n  } catch (error) {\n    handleError(error)\n    return null\n  }\n}\n\nasync function resolveRegistryDependencies(\n  url: string,\n  config: Config,\n): Promise<string[]> {\n  const visited = new Set<string>()\n  const payload: string[] = []\n\n  async function resolveDependencies(itemUrl: string) {\n    const url = getRegistryUrl(\n      isUrl(itemUrl) ? itemUrl : `styles/${config.style}/${itemUrl}.json`,\n    )\n\n    if (visited.has(url)) {\n      return\n    }\n\n    visited.add(url)\n\n    try {\n      const [result] = await fetchRegistry([url])\n      const item = registryItemSchema.parse(result)\n      payload.push(url)\n\n      if (item.registryDependencies) {\n        for (const dependency of item.registryDependencies) {\n          await resolveDependencies(dependency)\n        }\n      }\n    } catch (error) {\n      console.error(\n        `Error fetching or parsing registry item at ${itemUrl}:`,\n        error,\n      )\n    }\n  }\n\n  await resolveDependencies(url)\n  return Array.from(new Set(payload))\n}\n\nexport async function registryGetTheme(name: string, config: Config) {\n  const baseColor = await getRegistryBaseColor(name)\n  if (!baseColor) {\n    return null\n  }\n\n  // TODO: Move this to the registry i.e registry:theme.\n  const theme = {\n    name,\n    type: 'registry:theme',\n    tailwind: {\n      config: {\n        theme: {\n          extend: {\n            borderRadius: {\n              lg: 'var(--radius)',\n              md: 'calc(var(--radius) - 2px)',\n              sm: 'calc(var(--radius) - 4px)',\n            },\n            colors: {},\n          },\n        },\n      },\n    },\n    cssVars: {\n      light: {\n        radius: '0.5rem',\n      },\n      dark: {},\n    },\n  } satisfies z.infer<typeof registryItemSchema>\n\n  return theme\n}\n\nfunction getRegistryUrl(path: string) {\n  if (isUrl(path)) {\n    // If the url contains /chat/b/, we assume it's the v0 registry.\n    // We need to add the /json suffix if it's missing.\n    const url = new URL(path)\n    if (url.pathname.match(/\\/chat\\/b\\//) && !url.pathname.endsWith('/json')) {\n      url.pathname = `${url.pathname}/json`\n    }\n\n    return url.toString()\n  }\n\n  return `${REGISTRY_URL}/${path}`\n}\n\nfunction isUrl(path: string) {\n  try {\n    new URL(path)\n    return true\n  } catch (error) {\n    return false\n  }\n}\n"],"mappings":"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","names":["cyan","green","red","yellow","highlighter","logger","args","highlighter","handleError","error","logger","key","value","highlighter","z","registryItemTypeSchema","registryItemFileSchema","registryItemTailwindSchema","registryItemCssVarsSchema","registryItemSchema","registryIndexSchema","stylesSchema","registryBaseColorSchema","registryResolvedItemsTreeSchema","deepmerge","HttpsProxyAgent","fetch","path","z","agent","HttpsProxyAgent","getRegistryIndex","result","fetchRegistry","registryIndexSchema","error","logger","handleError","getRegistryStyles","stylesSchema","fetchRegistry","paths","config","readConfig","headers","path","url","getRegistryUrl","response","fetch","agent","errorMessages","highlighter","result","message","error","logger","handleError","getRegistryItemFileTargetPath","file","override","registryResolveItemsTree","names","getRegistryIndex","registryDependencies","name","itemRegistryDependencies","resolveRegistryDependencies","uniqueRegistryDependencies","payload","z","registryItemSchema","docs","item","registryResolvedItemsTreeSchema","deepmerge","visited","resolveDependencies","itemUrl","isUrl","dependency","getRegistryUrl","path","isUrl","url","REGISTRY_URL"]}