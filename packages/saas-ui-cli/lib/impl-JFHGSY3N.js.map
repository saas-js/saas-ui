{"version":3,"sources":["../src/commands/diff/impl.ts"],"sourcesContent":["import { type Change, diffLines } from 'diff'\nimport { existsSync, promises as fs } from 'node:fs'\nimport path from 'node:path'\nimport { z } from 'zod'\n\nimport type { LocalContext } from '#context'\nimport { detectMonorepo } from '#utils/detect-monorepo'\nimport { type Config, getConfig } from '#utils/get-config'\nimport { handleError } from '#utils/handle-error'\nimport { highlighter } from '#utils/highlighter'\nimport { logger } from '#utils/logger'\nimport {\n  getRegistryIndex,\n  getRegistryItem,\n  getRegistryItemFileTargetPath,\n  registryResolveItemsTree,\n} from '#utils/registry'\nimport { parseRegistryAndItemFromString } from '#utils/registry/parser'\nimport {\n  type RegistryItem,\n  registryItemFileSchema,\n} from '#utils/registry/schema'\nimport { transform } from '#utils/transformers'\nimport { transformImport } from '#utils/transformers/transform-import'\nimport { transformRsc } from '#utils/transformers/transform-rsc'\n\nconst diffOptionsSchema = z.object({\n  component: z.string().optional(),\n  yes: z.boolean(),\n  cwd: z.string().optional(),\n})\n\ntype DiffOptions = z.infer<typeof diffOptionsSchema>\n\ntype RegistryIndexItem = Omit<RegistryItem, 'files'> & {\n  files?: Array<string | z.infer<typeof registryItemFileSchema>>\n}\n\nexport async function diff(\n  this: LocalContext,\n  flags: Omit<DiffOptions, 'component'>,\n  ...components: Array<string>\n): Promise<void> {\n  try {\n    let normalizedComponent = components[0]\n    if (\n      normalizedComponent &&\n      normalizedComponent.includes('/') &&\n      !normalizedComponent.startsWith('@')\n    ) {\n      normalizedComponent = `@${normalizedComponent}`\n    }\n\n    const options = diffOptionsSchema.parse({\n      ...flags,\n      component: normalizedComponent,\n      cwd: flags.cwd ?? process.cwd(),\n    })\n\n    let cwd = path.resolve(options.cwd!)\n\n    if (!existsSync(cwd)) {\n      logger.error(`The path ${cwd} does not exist. Please try again.`)\n      process.exit(1)\n    }\n\n    const monorepoInfo = await detectMonorepo(cwd)\n    logger.debug(`Monorepo detected: ${monorepoInfo.isMonorepo}`)\n\n    let componentsJsonPath = path.resolve(cwd, 'components.json')\n\n    if (!existsSync(componentsJsonPath) && monorepoInfo.isMonorepo) {\n      logger.debug(`Looking for components.json in monorepo packages...`)\n\n      const uiPackagePath = path.join(cwd, 'packages', 'ui', 'components.json')\n\n      if (existsSync(uiPackagePath)) {\n        cwd = path.join(cwd, 'packages', 'ui')\n        componentsJsonPath = uiPackagePath\n        logger.info(\n          `Detected monorepo. Checking components in ${highlighter.info('packages/ui/')}`,\n        )\n        logger.break()\n      } else if (monorepoInfo.root) {\n        const rootUiPath = path.join(\n          monorepoInfo.root,\n          'packages',\n          'ui',\n          'components.json',\n        )\n\n        if (existsSync(rootUiPath)) {\n          cwd = path.join(monorepoInfo.root, 'packages', 'ui')\n          componentsJsonPath = rootUiPath\n          logger.info(\n            `Detected monorepo. Checking components in ${highlighter.info('packages/ui/')}`,\n          )\n          logger.break()\n        }\n      }\n    }\n\n    const config = await getConfig(cwd)\n    if (!config) {\n      logger.warn(\n        `Configuration is missing. Please run ${highlighter.info(\n          'init',\n        )} to create a components.json file.`,\n      )\n      process.exit(1)\n    }\n\n    if (!options.component) {\n      await checkAllComponents(config)\n    } else {\n      const { registry } = parseRegistryAndItemFromString(options.component)\n\n      if (registry) {\n        await checkNamespacedComponent(options.component, config)\n      } else {\n        const registryIndex = await getRegistryIndex()\n        if (!registryIndex) {\n          handleError(new Error('Failed to fetch registry index.'))\n          process.exit(1)\n        }\n        await checkSingleComponent(options.component, registryIndex, config)\n      }\n    }\n  } catch (error) {\n    handleError(error)\n  }\n}\n\nasync function checkAllComponents(config: Config) {\n  const registriesByNamespace = new Map<\n    string | null,\n    Array<RegistryIndexItem>\n  >()\n\n  const defaultIndex = await getRegistryIndex()\n  if (defaultIndex) {\n    registriesByNamespace.set(null, defaultIndex)\n  }\n\n  if (config.registries) {\n    for (const [namespace, registryConfig] of Object.entries(\n      config.registries,\n    )) {\n      try {\n        const registryUrl =\n          typeof registryConfig === 'string'\n            ? registryConfig\n            : registryConfig.url\n\n        const indexUrl = extractRegistryIndexUrl(registryUrl)\n        const index = await fetchRegistryIndexFromUrl(indexUrl)\n\n        if (index) {\n          registriesByNamespace.set(namespace, index)\n        }\n      } catch (error) {\n        logger.debug(`Failed to fetch index for ${namespace}:`, error)\n      }\n    }\n  }\n\n  if (registriesByNamespace.size === 0) {\n    logger.error('Failed to fetch any registry indices.')\n    process.exit(1)\n  }\n\n  const projectComponents: Array<{\n    component: RegistryIndexItem\n    namespace: string | null\n    fullName: string\n  }> = []\n\n  const seenFilePaths = new Set<string>()\n\n  for (const [namespace, registryIndex] of registriesByNamespace) {\n    for (const item of registryIndex) {\n      if (!item.files?.length) continue\n\n      const componentFilePaths = getComponentFilePaths(item, config)\n\n      const isAlreadySeen = componentFilePaths.some((filePath) =>\n        seenFilePaths.has(filePath),\n      )\n\n      if (isAlreadySeen) {\n        continue\n      }\n\n      const exists = await checkComponentExists(item, config)\n      if (exists) {\n        componentFilePaths.forEach((filePath) => seenFilePaths.add(filePath))\n\n        projectComponents.push({\n          component: item,\n          namespace,\n          fullName: namespace ? `${namespace}/${item.name}` : item.name,\n        })\n      }\n    }\n  }\n\n  if (projectComponents.length === 0) {\n    logger.info('No components found in your project.')\n    process.exit(0)\n  }\n\n  const componentsWithUpdates = []\n  for (const { fullName } of projectComponents) {\n    const changes = await diffComponentByName(fullName, config)\n    if (changes.length) {\n      componentsWithUpdates.push({\n        name: fullName,\n        changes,\n      })\n    }\n  }\n\n  if (!componentsWithUpdates.length) {\n    logger.info('All components are up to date.')\n    process.exit(0)\n  }\n\n  logger.info('The following components have updates available:')\n  logger.break()\n  for (const component of componentsWithUpdates) {\n    logger.info(`- ${highlighter.info(component.name)}`)\n    for (const change of component.changes) {\n      logger.log(`  - ${change.filePath}`)\n    }\n  }\n  logger.break()\n  logger.info(\n    `Run ${highlighter.success(`sui diff <component>`)} to see the changes.`,\n  )\n  logger.info(\n    `Run ${highlighter.success(`sui add ${componentsWithUpdates.map((component) => component.name).join(' ')} --overwrite`)} to update the component(s).`,\n  )\n}\n\nfunction extractRegistryIndexUrl(registryUrl: string): string {\n  // \"https://saas-ui.dev/r/styles/{style}/{name}.json\" -> \"https://saas-ui.dev/r/index.json\"\n\n  try {\n    const url = new URL(registryUrl)\n    const pathParts = url.pathname.split('/')\n\n    const rIndex = pathParts.findIndex((part) => part === 'r')\n    if (rIndex !== -1) {\n      const basePath = pathParts.slice(0, rIndex + 1).join('/')\n      return `${url.origin}${basePath}/index.json`\n    }\n\n    return `${url.origin}/index.json`\n  } catch {\n    const baseUrl =\n      registryUrl.split('/styles/')[0] || registryUrl.split('/{')[0]\n    return `${baseUrl}/index.json`\n  }\n}\n\nasync function fetchRegistryIndexFromUrl(\n  url: string,\n): Promise<Array<RegistryIndexItem> | null> {\n  try {\n    const { fetchRegistry } = await import('#utils/registry/fetcher')\n    const { registryIndexSchema } = await import('#utils/registry/schema')\n\n    const [result] = await fetchRegistry([url])\n    return registryIndexSchema.parse(result)\n  } catch (error) {\n    return null\n  }\n}\n\nasync function diffComponentByName(\n  componentName: string,\n  config: Config,\n): Promise<Array<{ filePath: string; patch: Change[] }>> {\n  const tree = await registryResolveItemsTree([componentName], config)\n  if (!tree || !tree.files) {\n    return []\n  }\n\n  return diffComponentFromTree(tree, config)\n}\n\nasync function checkSingleComponent(\n  componentName: string,\n  registryIndex: Array<RegistryIndexItem>,\n  config: Config,\n) {\n  const component = registryIndex.find((item) => item.name === componentName)\n\n  if (!component) {\n    logger.error(\n      `The component ${highlighter.info(\n        componentName,\n      )} does not exist in the registry.`,\n    )\n    process.exit(1)\n  }\n\n  const exists = await checkComponentExists(component, config)\n  if (!exists) {\n    logger.error(\n      `The component ${highlighter.info(\n        componentName,\n      )} is not installed in your project.`,\n    )\n    process.exit(1)\n  }\n\n  const changes = await diffComponent(component, config)\n\n  if (!changes.length) {\n    logger.info(`No updates found for ${highlighter.info(componentName)}.`)\n    process.exit(0)\n  }\n\n  logger.info(`Updates available for ${highlighter.info(componentName)}:`)\n  logger.break()\n  for (const change of changes) {\n    logger.info(`File: ${highlighter.info(change.filePath)}`)\n    logger.break()\n    await printDiff(change.patch)\n    logger.break()\n  }\n}\n\nasync function checkNamespacedComponent(componentName: string, config: Config) {\n  const { registry, item } = parseRegistryAndItemFromString(componentName)\n\n  if (!registry || !item) {\n    logger.error(`Invalid component name: ${highlighter.info(componentName)}`)\n    process.exit(1)\n  }\n\n  if (!config.registries || !config.registries[registry]) {\n    logger.error(`Registry \"${registry}\" is not configured in components.json`)\n    process.exit(1)\n  }\n\n  const registryItem = await getRegistryItem(config, componentName)\n\n  if (!registryItem) {\n    logger.error(\n      `The component ${highlighter.info(componentName)} does not exist in the registry.`,\n    )\n    process.exit(1)\n  }\n\n  const tree = await registryResolveItemsTree([componentName], config)\n  if (!tree || !tree.files) {\n    logger.error(\n      `The component ${highlighter.info(componentName)} is not installed in your project.`,\n    )\n    process.exit(1)\n  }\n\n  let hasInstalledFiles = false\n  for (const file of tree.files) {\n    if (!file.content) continue\n\n    const targetDir = getRegistryItemFileTargetPath(file, config)\n    const fileName = path.basename(file.path)\n    let filePath = path.join(targetDir, fileName)\n\n    if (file.target) {\n      filePath = file.target.startsWith('~/')\n        ? path.join(config.resolvedPaths.cwd, file.target.replace('~/', ''))\n        : path.join(config.resolvedPaths.cwd, file.target)\n    }\n\n    if (!config.tsx) {\n      filePath = filePath.replace(/\\.tsx?$/, (match) =>\n        match === '.tsx' ? '.jsx' : '.js',\n      )\n    }\n\n    if (existsSync(filePath)) {\n      hasInstalledFiles = true\n      break\n    }\n  }\n\n  if (!hasInstalledFiles) {\n    logger.error(\n      `The component ${highlighter.info(componentName)} is not installed in your project.`,\n    )\n    process.exit(1)\n  }\n\n  const changes = await diffComponentFromTree(tree, config)\n\n  if (!changes.length) {\n    logger.info(`No updates found for ${highlighter.info(componentName)}.`)\n    process.exit(0)\n  }\n\n  logger.info(`Updates available for ${highlighter.info(componentName)}:`)\n  logger.break()\n  for (const change of changes) {\n    logger.info(`File: ${highlighter.info(change.filePath)}`)\n    logger.break()\n    await printDiff(change.patch)\n    logger.break()\n  }\n}\n\nfunction getComponentFilePaths(\n  component: RegistryIndexItem,\n  config: Config,\n): Array<string> {\n  const filePaths: Array<string> = []\n\n  if (!component.files?.length) return filePaths\n\n  for (const file of component.files) {\n    if (typeof file === 'string') continue\n\n    const targetDir = getRegistryItemFileTargetPath(file, config)\n    const fileName = path.basename(file.path)\n    let filePath = path.join(targetDir, fileName)\n\n    if (!config.tsx) {\n      filePath = filePath.replace(/\\.tsx?$/, (match) =>\n        match === '.tsx' ? '.jsx' : '.js',\n      )\n    }\n\n    filePaths.push(filePath)\n  }\n\n  return filePaths\n}\n\nasync function checkComponentExists(\n  component: RegistryIndexItem,\n  config: Config,\n): Promise<boolean> {\n  const filePaths = getComponentFilePaths(component, config)\n\n  for (const filePath of filePaths) {\n    if (existsSync(filePath)) {\n      return true\n    }\n  }\n\n  return false\n}\n\nasync function diffComponent(\n  component: RegistryIndexItem,\n  config: Config,\n): Promise<Array<{ filePath: string; patch: Change[] }>> {\n  const tree = await registryResolveItemsTree([component.name], config)\n  if (!tree || !tree.files) {\n    return []\n  }\n\n  return diffComponentFromTree(tree, config)\n}\n\nasync function diffComponentFromTree(\n  tree: Awaited<ReturnType<typeof registryResolveItemsTree>>,\n  config: Config,\n): Promise<Array<{ filePath: string; patch: Change[] }>> {\n  if (!tree || !tree.files) {\n    return []\n  }\n\n  const changes = []\n\n  for (const file of tree.files) {\n    if (!file.content) continue\n\n    const targetDir = getRegistryItemFileTargetPath(file, config)\n    const fileName = path.basename(file.path)\n    let filePath = path.join(targetDir, fileName)\n\n    if (file.target) {\n      filePath = file.target.startsWith('~/')\n        ? path.join(config.resolvedPaths.cwd, file.target.replace('~/', ''))\n        : path.join(config.resolvedPaths.cwd, file.target)\n    }\n\n    if (!config.tsx) {\n      filePath = filePath.replace(/\\.tsx?$/, (match) =>\n        match === '.tsx' ? '.jsx' : '.js',\n      )\n    }\n\n    if (!existsSync(filePath)) {\n      continue\n    }\n\n    const currentContent = await fs.readFile(filePath, 'utf8')\n\n    const registryContent = await transform(\n      {\n        filename: file.path,\n        raw: file.content,\n        config,\n        transformJsx: !config.tsx,\n      },\n      [transformImport, transformRsc],\n    )\n\n    const patch = diffLines(currentContent, registryContent)\n    if (patch.length > 1) {\n      changes.push({\n        filePath: path.relative(config.resolvedPaths.cwd, filePath),\n        patch,\n      })\n    }\n  }\n\n  return changes\n}\n\nasync function printDiff(diff: Change[]) {\n  diff.forEach((part) => {\n    if (part) {\n      if (part.added) {\n        return process.stdout.write(highlighter.success(`+ ${part.value}`))\n      }\n      if (part.removed) {\n        return process.stdout.write(highlighter.error(`- ${part.value}`))\n      }\n      return process.stdout.write(`  ${part.value}`)\n    }\n  })\n}\n"],"mappings":"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","names":["diffLines","existsSync","fs","path","z","diffOptionsSchema","z","diff","flags","components","normalizedComponent","options","cwd","path","existsSync","logger","monorepoInfo","detectMonorepo","componentsJsonPath","uiPackagePath","highlighter","rootUiPath","config","getConfig","checkAllComponents","registry","parseRegistryAndItemFromString","checkNamespacedComponent","registryIndex","getRegistryIndex","handleError","checkSingleComponent","error","registriesByNamespace","defaultIndex","namespace","registryConfig","registryUrl","indexUrl","extractRegistryIndexUrl","index","fetchRegistryIndexFromUrl","projectComponents","seenFilePaths","item","componentFilePaths","getComponentFilePaths","filePath","checkComponentExists","componentsWithUpdates","fullName","changes","diffComponentByName","component","change","url","pathParts","rIndex","part","basePath","fetchRegistry","registryIndexSchema","result","componentName","tree","registryResolveItemsTree","diffComponentFromTree","diffComponent","printDiff","getRegistryItem","hasInstalledFiles","file","targetDir","getRegistryItemFileTargetPath","fileName","match","filePaths","currentContent","fs","registryContent","transform","transformImport","transformRsc","patch","diffLines"]}