{"version":3,"sources":["../src/utils/registry/fetcher.ts","../src/utils/registry/env.ts","../src/utils/registry/errors.ts","../src/utils/registry/parser.ts","../src/utils/registry/utils.ts","../src/utils/registry/builder.ts","../src/utils/registry/context.ts"],"sourcesContent":["import { HttpsProxyAgent } from 'https-proxy-agent'\r\nimport fetch from 'node-fetch'\r\nimport { promises as fs } from 'node:fs'\r\nimport { z } from 'zod'\r\n\r\nimport { resolveRegistryUrl } from '#utils/registry/builder'\r\nimport { getRegistryHeadersFromContext } from '#utils/registry/context'\r\nimport {\r\n  RegistryFetchError,\r\n  RegistryForbiddenError,\r\n  RegistryLocalFileError,\r\n  RegistryNotFoundError,\r\n  RegistryUnauthorizedError,\r\n} from '#utils/registry/errors'\r\nimport { registryItemSchema } from '#utils/registry/schema'\r\n\r\nimport { RegistryParseError } from './errors'\r\n\r\nconst agent = process.env.https_proxy\r\n  ? new HttpsProxyAgent(process.env.https_proxy)\r\n  : undefined\r\n\r\nconst registryCache = new Map<string, Promise<any>>()\r\n\r\nexport function clearRegistryCache() {\r\n  registryCache.clear()\r\n}\r\n\r\nexport async function fetchRegistry(\r\n  paths: Array<string>,\r\n  options: { useCache?: boolean } = {},\r\n) {\r\n  options = {\r\n    useCache: true,\r\n    ...options,\r\n  }\r\n\r\n  const results = await Promise.all(\r\n    paths.map(async (path) => {\r\n      const url = resolveRegistryUrl(path)\r\n\r\n      if (options.useCache && registryCache.has(url)) {\r\n        return registryCache.get(url)\r\n      }\r\n\r\n      const fetchPromise = (async () => {\r\n        const headers = getRegistryHeadersFromContext(url)\r\n\r\n        const response = await fetch(url, {\r\n          agent,\r\n          headers: {\r\n            ...headers,\r\n          },\r\n        })\r\n\r\n        if (!response.ok) {\r\n          let messageFromServer = undefined\r\n\r\n          if (\r\n            response.headers.get('content-type')?.includes('application/json')\r\n          ) {\r\n            const json = await response.json()\r\n            const parsed = z\r\n              .object({\r\n                // RFC 7807\r\n                detail: z.string().optional(),\r\n                title: z.string().optional(),\r\n                message: z.string().optional(),\r\n                error: z.string().optional(),\r\n              })\r\n              .safeParse(json)\r\n\r\n            if (parsed.success) {\r\n              messageFromServer = parsed.data.detail || parsed.data.message\r\n\r\n              if (parsed.data.error) {\r\n                messageFromServer = `[${parsed.data.error}] ${messageFromServer}`\r\n              }\r\n            }\r\n          }\r\n\r\n          if (response.status === 401) {\r\n            throw new RegistryUnauthorizedError(url, messageFromServer)\r\n          }\r\n\r\n          if (response.status === 404) {\r\n            throw new RegistryNotFoundError(url, messageFromServer)\r\n          }\r\n\r\n          if (response.status === 403) {\r\n            throw new RegistryForbiddenError(url, messageFromServer)\r\n          }\r\n\r\n          throw new RegistryFetchError(\r\n            url,\r\n            response.status,\r\n            undefined,\r\n            messageFromServer,\r\n          )\r\n        }\r\n\r\n        return response.json()\r\n      })()\r\n\r\n      if (options.useCache) {\r\n        registryCache.set(url, fetchPromise)\r\n      }\r\n\r\n      return fetchPromise\r\n    }),\r\n  )\r\n\r\n  return results\r\n}\r\n\r\nexport async function fetchRegistryLocal(filePath: string) {\r\n  try {\r\n    const content = await fs.readFile(filePath, 'utf-8')\r\n    const json = JSON.parse(content)\r\n    try {\r\n      return registryItemSchema.parse(json)\r\n    } catch (error) {\r\n      throw new RegistryParseError(filePath, error)\r\n    }\r\n  } catch (error) {\r\n    if (error instanceof RegistryParseError) {\r\n      throw error\r\n    }\r\n    throw new RegistryLocalFileError(filePath, error)\r\n  }\r\n}\r\n","export function expandEnvVars(value: string): string {\n  return value.replace(/\\${(\\w+)}/g, (_match, key) => process.env[key] || '')\n}\n\nexport function extractEnvVars(value: string): Array<string> {\n  const vars: Array<string> = []\n  const regex = /\\${(\\w+)}/g\n  let match: RegExpExecArray | null\n\n  while ((match = regex.exec(value)) !== null) {\n    if (match[1]) {\n      vars.push(match[1])\n    }\n  }\n\n  return vars\n}\n","import { z } from 'zod'\n\nexport const RegistryErrorCode = {\n  NETWORK_ERROR: 'NETWORK_ERROR',\n  NOT_FOUND: 'NOT_FOUND',\n  UNAUTHORIZED: 'UNAUTHORIZED',\n  FORBIDDEN: 'FORBIDDEN',\n  FETCH_ERROR: 'FETCH_ERROR',\n  NOT_CONFIGURED: 'NOT_CONFIGURED',\n  INVALID_CONFIG: 'INVALID_CONFIG',\n  MISSING_ENV_VARS: 'MISSING_ENV_VARS',\n  LOCAL_FILE_ERROR: 'LOCAL_FILE_ERROR',\n  PARSE_ERROR: 'PARSE_ERROR',\n  VALIDATION_ERROR: 'VALIDATION_ERROR',\n  UNKNOWN_ERROR: 'UNKNOWN_ERROR',\n} as const\n\nexport type RegistryErrorCode =\n  (typeof RegistryErrorCode)[keyof typeof RegistryErrorCode]\n\nexport class RegistryError extends Error {\n  public readonly code: RegistryErrorCode\n  public readonly statusCode?: number\n  public readonly context?: Record<string, unknown>\n  public readonly suggestion?: string\n  public readonly timestamp: Date\n  public override readonly cause?: unknown\n\n  constructor(\n    message: string,\n    options: {\n      code?: RegistryErrorCode\n      statusCode?: number\n      cause?: unknown\n      context?: Record<string, unknown>\n      suggestion?: string\n    } = {},\n  ) {\n    super(message)\n    this.name = 'RegistryError'\n    this.code = options.code || RegistryErrorCode.UNKNOWN_ERROR\n    this.statusCode = options.statusCode\n    this.cause = options.cause\n    this.context = options.context\n    this.suggestion = options.suggestion\n    this.timestamp = new Date()\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor)\n    }\n  }\n}\n\nexport class RegistryNotFoundError extends RegistryError {\n  constructor(\n    public readonly url: string,\n    cause?: unknown,\n  ) {\n    const message = `The item at ${url} was not found. It may not exist at the registry.`\n\n    super(message, {\n      code: RegistryErrorCode.NOT_FOUND,\n      statusCode: 404,\n      cause,\n      context: { url },\n      suggestion:\n        'Check if the item name is correct and the registry URL is accessible.',\n    })\n    this.name = 'RegistryNotFoundError'\n  }\n}\n\nexport class RegistryUnauthorizedError extends RegistryError {\n  constructor(\n    public readonly url: string,\n    cause?: unknown,\n  ) {\n    const message = `You are not authorized to access the item at ${url}. If this is a remote registry, you may need to authenticate.`\n\n    super(message, {\n      code: RegistryErrorCode.UNAUTHORIZED,\n      statusCode: 401,\n      cause,\n      context: { url },\n      suggestion:\n        'Check your authentication credentials and environment variables.',\n    })\n    this.name = 'RegistryUnauthorizedError'\n  }\n}\n\nexport class RegistryForbiddenError extends RegistryError {\n  constructor(\n    public readonly url: string,\n    cause?: unknown,\n  ) {\n    const message = `You are not authorized to access the item at ${url}. If this is a remote registry, you may need to authenticate.`\n\n    super(message, {\n      code: RegistryErrorCode.FORBIDDEN,\n      statusCode: 403,\n      cause,\n      context: { url },\n      suggestion:\n        'Check your authentication credentials and environment variables.',\n    })\n    this.name = 'RegistryForbiddenError'\n  }\n}\n\nexport class RegistryFetchError extends RegistryError {\n  constructor(\n    public readonly url: string,\n    statusCode?: number,\n    public readonly responseBody?: string,\n    cause?: unknown,\n  ) {\n    const baseMessage = statusCode\n      ? `Failed to fetch from registry (${statusCode}): ${url}`\n      : `Failed to fetch from registry: ${url}`\n\n    const message =\n      typeof cause === 'string' && cause\n        ? `${baseMessage} - ${cause}`\n        : baseMessage\n\n    let suggestion = 'Check your network connection and try again.'\n    if (statusCode === 404) {\n      suggestion =\n        'The requested resource was not found. Check the URL or item name.'\n    } else if (statusCode === 500) {\n      suggestion = 'The registry server encountered an error. Try again later.'\n    } else if (statusCode && statusCode >= 400 && statusCode < 500) {\n      suggestion = 'There was a client error. Check your request parameters.'\n    }\n\n    super(message, {\n      code: RegistryErrorCode.FETCH_ERROR,\n      statusCode,\n      cause,\n      context: { url, responseBody },\n      suggestion,\n    })\n    this.name = 'RegistryFetchError'\n  }\n}\n\nexport class RegistryNotConfiguredError extends RegistryError {\n  constructor(public readonly registryName: string | null) {\n    const message = registryName\n      ? `Unknown registry \"${registryName}\". Make sure it is defined in components.json as follows:\n{\n  \"registries\": {\n    \"${registryName}\": \"[URL_TO_REGISTRY]\"\n  }\n}`\n      : 'Unknown registry. Make sure it is defined in components.json under \"registries\".'\n\n    super(message, {\n      code: RegistryErrorCode.NOT_CONFIGURED,\n      context: { registryName },\n      suggestion:\n        'Add the registry configuration to your components.json file.',\n    })\n    this.name = 'RegistryNotConfiguredError'\n  }\n}\n\nexport class RegistryLocalFileError extends RegistryError {\n  constructor(\n    public readonly filePath: string,\n    cause?: unknown,\n  ) {\n    super(`Failed to read local registry file: ${filePath}`, {\n      code: RegistryErrorCode.LOCAL_FILE_ERROR,\n      cause,\n      context: { filePath },\n      suggestion: 'Check if the file exists and you have read permissions.',\n    })\n    this.name = 'RegistryLocalFileError'\n  }\n}\n\nexport class RegistryParseError extends RegistryError {\n  public readonly parseError: unknown\n\n  constructor(\n    public readonly item: string,\n    parseError: unknown,\n  ) {\n    let message = `Failed to parse registry item: ${item}`\n\n    if (parseError instanceof z.ZodError) {\n      message = `Failed to parse registry item: ${item}\\n${parseError.message}`\n    }\n\n    super(message, {\n      code: RegistryErrorCode.PARSE_ERROR,\n      cause: parseError,\n      context: { item },\n      suggestion:\n        'The registry item may be corrupted or have an invalid format.',\n    })\n\n    this.parseError = parseError\n    this.name = 'RegistryParseError'\n  }\n}\n","const REGISTRY_PATTERN = /^(@[a-zA-Z0-9](?:[a-zA-Z0-9-_]*[a-zA-Z0-9])?)\\/(.+)$/\r\n\r\nexport function parseRegistryAndItemFromString(name: string) {\r\n  if (!name.startsWith('@')) {\r\n    return {\r\n      registry: null,\r\n      item: name,\r\n    }\r\n  }\r\n\r\n  const match = name.match(REGISTRY_PATTERN)\r\n  if (match) {\r\n    return {\r\n      registry: match[1],\r\n      item: match[2],\r\n    }\r\n  }\r\n\r\n  return {\r\n    registry: null,\r\n    item: name,\r\n  }\r\n}\r\n","export function isUrl(path: string): boolean {\r\n  try {\r\n    new URL(path)\r\n    return true\r\n  } catch {\r\n    return false\r\n  }\r\n}\r\n\r\nexport function isLocalFile(path: string): boolean {\r\n  return path.startsWith('.') || path.startsWith('/')\r\n}\r\n","import { REGISTRY_URL } from '#constants'\nimport type { Config } from '#utils/get-config'\nimport { expandEnvVars } from '#utils/registry/env'\nimport { RegistryNotConfiguredError } from '#utils/registry/errors'\nimport { parseRegistryAndItemFromString } from '#utils/registry/parser'\nimport { isUrl } from '#utils/registry/utils'\n\nconst NAME_PLACEHOLDER = '{name}'\nconst STYLE_PLACEHOLDER = '{style}'\nconst ENV_VAR_PATTERN = /\\${(\\w+)}/g\n\nexport interface RegistryConfigItem {\n  url: string\n  headers?: Record<string, string>\n  params?: Record<string, string>\n}\n\nexport function buildUrlAndHeadersForRegistryItem(\n  name: string,\n  config?: Config,\n): { url: string; headers: Record<string, string> } | null {\n  const { registry, item } = parseRegistryAndItemFromString(name)\n\n  if (!registry || !item) {\n    return null\n  }\n\n  const registries = config?.registries || {}\n  const registryConfig = registries[registry]\n  if (!registryConfig) {\n    throw new RegistryNotConfiguredError(registry)\n  }\n\n  const url = buildUrlFromRegistryConfig(item, registryConfig, config)\n  if (!url) {\n    throw new RegistryNotConfiguredError(registry)\n  }\n\n  return {\n    url,\n    headers: buildHeadersFromRegistryConfig(registryConfig),\n  }\n}\n\nexport function buildUrlFromRegistryConfig(\n  item: string,\n  registryConfig: string | RegistryConfigItem | undefined,\n  config?: Config,\n): string | null {\n  if (!registryConfig) {\n    return null\n  }\n\n  if (typeof registryConfig === 'string') {\n    let url = registryConfig.replace(NAME_PLACEHOLDER, item)\n    if (config?.style && url.includes(STYLE_PLACEHOLDER)) {\n      url = url.replace(STYLE_PLACEHOLDER, config.style)\n    }\n    return expandEnvVars(url)\n  }\n\n  let baseUrl = registryConfig.url.replace(NAME_PLACEHOLDER, item)\n  if (config?.style && baseUrl.includes(STYLE_PLACEHOLDER)) {\n    baseUrl = baseUrl.replace(STYLE_PLACEHOLDER, config.style)\n  }\n  baseUrl = expandEnvVars(baseUrl)\n\n  if (!registryConfig.params) {\n    return baseUrl\n  }\n\n  return appendQueryParams(baseUrl, registryConfig.params)\n}\n\nexport function buildHeadersFromRegistryConfig(\n  config: string | RegistryConfigItem,\n): Record<string, string> {\n  if (typeof config === 'string' || !config.headers) {\n    return {}\n  }\n\n  const headers: Record<string, string> = {}\n\n  for (const [key, value] of Object.entries(config.headers)) {\n    const expandedValue = expandEnvVars(value)\n\n    if (shouldIncludeHeader(value, expandedValue)) {\n      headers[key] = expandedValue\n    }\n  }\n\n  return headers\n}\n\nfunction appendQueryParams(\n  baseUrl: string,\n  params: Record<string, string>,\n): string {\n  const urlParams = new URLSearchParams()\n\n  for (const [key, value] of Object.entries(params)) {\n    const expandedValue = expandEnvVars(value)\n    if (expandedValue) {\n      urlParams.append(key, expandedValue)\n    }\n  }\n\n  const queryString = urlParams.toString()\n  if (!queryString) {\n    return baseUrl\n  }\n\n  const separator = baseUrl.includes('?') ? '&' : '?'\n  return `${baseUrl}${separator}${queryString}`\n}\n\nfunction shouldIncludeHeader(\n  originalValue: string,\n  expandedValue: string,\n): boolean {\n  const trimmedExpanded = expandedValue.trim()\n\n  if (!trimmedExpanded) {\n    return false\n  }\n\n  if (originalValue.includes('${')) {\n    const envVars = originalValue.match(ENV_VAR_PATTERN)\n    if (envVars) {\n      const templateWithoutVars = originalValue\n        .replace(ENV_VAR_PATTERN, '')\n        .trim()\n      return trimmedExpanded !== templateWithoutVars\n    }\n  }\n\n  return true\n}\n\nexport function resolveRegistryUrl(pathOrUrl: string): string {\n  if (isUrl(pathOrUrl)) {\n    const url = new URL(pathOrUrl)\n    if (url.pathname.match(/\\/chat\\/b\\//) && !url.pathname.endsWith('/json')) {\n      url.pathname = `${url.pathname}/json`\n    }\n\n    return url.toString()\n  }\n\n  return `${REGISTRY_URL}/${pathOrUrl}`\n}\n","interface RegistryContext {\r\n  headers: Record<string, Record<string, string>>\r\n}\r\n\r\nconst context: RegistryContext = {\r\n  headers: {},\r\n}\r\n\r\nexport function setRegistryHeaders(\r\n  headers: Record<string, Record<string, string>>,\r\n) {\r\n  context.headers = { ...context.headers, ...headers }\r\n}\r\n\r\nexport function getRegistryHeadersFromContext(\r\n  url: string,\r\n): Record<string, string> {\r\n  return context.headers[url] || {}\r\n}\r\n\r\nexport function clearRegistryContext() {\r\n  context.headers = {}\r\n}\r\n"],"mappings":"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","names":["HttpsProxyAgent","fetch","fs","z","expandEnvVars","value","_match","key","z","RegistryErrorCode","RegistryError","message","options","RegistryNotFoundError","url","cause","RegistryUnauthorizedError","RegistryForbiddenError","RegistryFetchError","statusCode","responseBody","baseMessage","suggestion","RegistryNotConfiguredError","registryName","RegistryLocalFileError","filePath","RegistryParseError","item","parseError","REGISTRY_PATTERN","parseRegistryAndItemFromString","name","match","isUrl","path","isLocalFile","NAME_PLACEHOLDER","STYLE_PLACEHOLDER","ENV_VAR_PATTERN","buildUrlAndHeadersForRegistryItem","name","config","registry","item","parseRegistryAndItemFromString","registryConfig","RegistryNotConfiguredError","url","buildUrlFromRegistryConfig","buildHeadersFromRegistryConfig","expandEnvVars","baseUrl","appendQueryParams","headers","key","value","expandedValue","shouldIncludeHeader","params","urlParams","queryString","separator","originalValue","trimmedExpanded","templateWithoutVars","resolveRegistryUrl","pathOrUrl","isUrl","REGISTRY_URL","context","setRegistryHeaders","headers","getRegistryHeadersFromContext","url","clearRegistryContext","agent","HttpsProxyAgent","registryCache","clearRegistryCache","fetchRegistry","paths","options","path","url","resolveRegistryUrl","fetchPromise","headers","getRegistryHeadersFromContext","response","fetch","messageFromServer","json","parsed","z","RegistryUnauthorizedError","RegistryNotFoundError","RegistryForbiddenError","RegistryFetchError","fetchRegistryLocal","filePath","content","fs","registryItemSchema","error","RegistryParseError","RegistryLocalFileError"]}