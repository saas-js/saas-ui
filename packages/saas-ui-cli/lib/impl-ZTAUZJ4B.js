import{a as x,f as w,h as C,i as I,j as $}from"./chunk-TXDPC5OL.js";import{a,b as t,c as d,d as j,f as u,g as k}from"./chunk-Y2SSMBR3.js";import"./chunk-L36FRG6H.js";import{diffLines as R}from"diff";import{existsSync as m,promises as A}from"fs";import f from"path";import{z as h}from"zod";var D=h.object({component:h.string().optional(),yes:h.boolean(),cwd:h.string().optional()});async function V(r,...o){try{let i=D.parse({...r,component:o[0],cwd:r.cwd??process.cwd()}),n=f.resolve(i.cwd);m(n)||(t.error(`The path ${n} does not exist. Please try again.`),process.exit(1));let e=await x(n);t.debug(`Monorepo detected: ${e.isMonorepo}`);let s=f.resolve(n,"components.json");if(!m(s)&&e.isMonorepo){t.debug("Looking for components.json in monorepo packages...");let l=f.join(n,"packages","ui","components.json");if(m(l))n=f.join(n,"packages","ui"),s=l,t.info(`Detected monorepo. Checking components in ${a.info("packages/ui/")}`),t.break();else if(e.root){let g=f.join(e.root,"packages","ui","components.json");m(g)&&(n=f.join(e.root,"packages","ui"),s=g,t.info(`Detected monorepo. Checking components in ${a.info("packages/ui/")}`),t.break())}}let c=await w(n);c||(t.warn(`Configuration is missing. Please run ${a.info("init")} to create a components.json file.`),process.exit(1));let p=await j();p||(d(new Error("Failed to fetch registry index.")),process.exit(1)),i.component?await O(i.component,p,c):await F(p,c)}catch(i){d(i)}}async function F(r,o){let i=[];for(let e of r){if(!e.files?.length)continue;await P(e,o)&&i.push(e)}i.length===0&&(t.info("No components found in your project."),process.exit(0));let n=[];for(let e of i){let s=await b(e,o);s.length&&n.push({name:e.name,changes:s})}n.length||(t.info("All components are up to date."),process.exit(0)),t.info("The following components have updates available:"),t.break();for(let e of n){t.info(`- ${a.info(e.name)}`);for(let s of e.changes)t.log(`  - ${s.filePath}`)}t.break(),t.info(`Run ${a.success("sui diff <component>")} to see the changes.`),t.info(`Run ${a.success(`sui add ${n.map(e=>e.name).join(" ")} --overwrite`)} to update the component(s).`)}async function O(r,o,i){let n=o.find(c=>c.name===r);n||(t.error(`The component ${a.info(r)} does not exist in the registry.`),process.exit(1)),await P(n,i)||(t.error(`The component ${a.info(r)} is not installed in your project.`),process.exit(1));let s=await b(n,i);s.length||(t.info(`No updates found for ${a.info(r)}.`),process.exit(0)),t.info(`Updates available for ${a.info(r)}:`),t.break();for(let c of s)t.info(`File: ${a.info(c.filePath)}`),t.break(),await S(c.patch),t.break()}async function P(r,o){if(!r.files?.length)return!1;for(let i of r.files){if(typeof i=="string")continue;let n=u(i,o),e=f.basename(i.path),s=f.join(n,e);if(o.tsx||(s=s.replace(/\.tsx?$/,c=>c===".tsx"?".jsx":".js")),m(s))return!0}return!1}async function b(r,o){let i=[],n=await k([r.name],o);if(!n||!n.files)return[];for(let e of n.files){if(!e.content)continue;let s=u(e,o),c=f.basename(e.path),p=f.join(s,c);if(e.target&&(p=e.target.startsWith("~/")?f.join(o.resolvedPaths.cwd,e.target.replace("~/","")):f.join(o.resolvedPaths.cwd,e.target)),o.tsx||(p=p.replace(/\.tsx?$/,v=>v===".tsx"?".jsx":".js")),!m(p))continue;let l=await A.readFile(p,"utf8"),g=await $({filename:e.path,raw:e.content,config:o,transformJsx:!o.tsx},[C,I]),y=R(l,g);y.length>1&&i.push({filePath:f.relative(o.resolvedPaths.cwd,p),patch:y})}return i}async function S(r){r.forEach(o=>{if(o)return o.added?process.stdout.write(a.success(`+ ${o.value}`)):o.removed?process.stdout.write(a.error(`- ${o.value}`)):process.stdout.write(`  ${o.value}`)})}export{V as diff};
//# sourceMappingURL=impl-ZTAUZJ4B.js.map