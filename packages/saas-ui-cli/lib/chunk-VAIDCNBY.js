var a=async({sourceFile:r,config:t})=>{let s=r.getImportDeclarations();for(let o of s){let e=l(o.getModuleSpecifierValue(),t);o.setModuleSpecifier(e)}return r};function l(r,t){if(!r.startsWith("@/"))return r;if(!r.startsWith("@/registry/")){if(/^@[^/]+\/[^/]+/.test(t.aliases.components))return r;let o=t.aliases.components.charAt(0);return r.replace(/^@\//,`${o}/`)}return r.match(/^@\/registry\/(.+)\/ui/)?r.replace(/^@\/registry\/(.+)\/ui/,t.aliases.ui??`${t.aliases.components}/ui`):t.aliases.components&&r.match(/^@\/registry\/(.+)\/components/)?r.replace(/^@\/registry\/(.+)\/components/,t.aliases.components):t.aliases.lib&&r.match(/^@\/registry\/(.+)\/lib/)?r.replace(/^@\/registry\/(.+)\/lib/,t.aliases.lib):t.aliases.hooks&&r.match(/^@\/registry\/(.+)\/hooks/)?r.replace(/^@\/registry\/(.+)\/hooks/,t.aliases.hooks):r.replace(/^@\/registry\/[^/]+/,t.aliases.components)}import{SyntaxKind as f}from"ts-morph";var i=async({sourceFile:r,config:t})=>{if(t.rsc)return r;let s=r.getFirstChildByKind(f.ExpressionStatement);return s?.getText()==='"use client"'&&s.remove(),r};import{promises as x}from"fs";import{tmpdir as T}from"os";import m from"path";import{Project as d,ScriptKind as w}from"ts-morph";import"zod";import*as n from"recast";import{transformFromAstSync as u}from"@babel/core";import{parse as y}from"@babel/parser";import g from"@babel/plugin-transform-typescript";var h={sourceType:"module",allowImportExportEverywhere:!0,allowReturnOutsideFunction:!0,startLine:1,tokens:!0,plugins:["asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","classStaticBlock","decimal","decorators-legacy","doExpressions","dynamicImport","exportDefaultFrom","exportNamespaceFrom","functionBind","functionSent","importAssertions","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{proposal:"minimal"}],["recordAndTuple",{syntaxType:"hash"}],"throwExpressions","topLevelAwait","v8intrinsic","typescript","jsx"]},p=async({sourceFile:r,config:t})=>{let s=r.getFullText();if(t.tsx)return s;let o=n.parse(s,{parser:{parse:c=>y(c,h)}}),e=u(o,s,{cloneInputAst:!1,code:!1,ast:!0,plugins:[g],configFile:!1});if(!e||!e.ast)throw new Error("Failed to transform JSX");return n.print(e.ast).code};var C=new d({compilerOptions:{}});async function F(r){let t=await x.mkdtemp(m.join(T(),"sui-"));return m.join(t,r)}async function W(r,t=[a,i]){let s=await F(r.filename),o=C.createSourceFile(s,r.raw,{scriptKind:w.TSX});for(let e of t)e({sourceFile:o,...r});return r.transformJsx?await p({sourceFile:o,...r}):o.getText()}export{a,i as b,W as c};
