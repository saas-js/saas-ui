{"version":3,"sources":["../src/utils/registry/index.ts"],"sourcesContent":["import deepmerge from 'deepmerge'\nimport { z } from 'zod'\n\nimport type { Config } from '#utils/get-config'\nimport { handleError } from '#utils/handle-error'\nimport { logger } from '#utils/logger'\nimport {\n  buildHeadersFromRegistryConfig,\n  buildUrlAndHeadersForRegistryItem,\n} from '#utils/registry/builder'\nimport {\n  clearRegistryContext,\n  setRegistryHeaders,\n} from '#utils/registry/context'\nimport { expandEnvVars } from '#utils/registry/env'\nimport {\n  RegistryNotConfiguredError,\n  RegistryParseError,\n} from '#utils/registry/errors'\nimport { fetchRegistry, fetchRegistryLocal } from '#utils/registry/fetcher'\nimport { parseRegistryAndItemFromString } from '#utils/registry/parser'\nimport {\n  registryBaseColorSchema,\n  registryIndexSchema,\n  registryItemSchema,\n  registryResolvedItemsTreeSchema,\n  stylesSchema,\n} from '#utils/registry/schema'\nimport { isLocalFile, isUrl } from '#utils/registry/utils'\n\nexport async function getRegistryIndex(config?: Config, namespace?: string) {\n  try {\n    let path: string\n\n    if (namespace) {\n      if (!config?.registries || !config.registries[namespace]) {\n        throw new RegistryNotConfiguredError(namespace)\n      }\n\n      const registryConfig = config.registries[namespace]\n      const headers = buildHeadersFromRegistryConfig(registryConfig)\n\n      let indexUrl: string\n      if (typeof registryConfig === 'string') {\n        indexUrl = registryConfig.replace('{name}', 'index')\n        indexUrl = indexUrl.replace(/\\/styles\\/[^/]+\\//, '/')\n        indexUrl = expandEnvVars(indexUrl)\n      } else {\n        indexUrl = registryConfig.url.replace('{name}', 'index')\n        indexUrl = indexUrl.replace(/\\/styles\\/[^/]+\\//, '/')\n        indexUrl = expandEnvVars(indexUrl)\n      }\n\n      setRegistryHeaders({ [indexUrl]: headers })\n      path = indexUrl\n    } else {\n      path = `r/index.json`\n    }\n\n    const [result] = await fetchRegistry([path])\n\n    return registryIndexSchema.parse(result)\n  } catch (error) {\n    logger.error('\\n')\n    handleError(error)\n  } finally {\n    if (namespace) {\n      clearRegistryContext()\n    }\n  }\n}\n\nexport async function getRegistryStyles() {\n  try {\n    const [result] = await fetchRegistry(['r/styles/index.json'])\n\n    return stylesSchema.parse(result)\n  } catch (error) {\n    logger.error('\\n')\n    handleError(error)\n    return []\n  }\n}\n\nasync function fetchRegistryItems(\n  items: Array<string>,\n  config: Config,\n  options: { useCache?: boolean } = {},\n) {\n  const results = await Promise.all(\n    items.map(async (item) => {\n      if (isLocalFile(item)) {\n        return fetchRegistryLocal(item)\n      }\n\n      if (isUrl(item)) {\n        const [result] = await fetchRegistry([item], options)\n        try {\n          return registryItemSchema.parse(result)\n        } catch (error) {\n          throw new RegistryParseError(item, error)\n        }\n      }\n\n      if (item.startsWith('@') && config?.registries) {\n        const paths = resolveRegistryItemsFromRegistries([item], config)\n        const [result] = await fetchRegistry(paths, options)\n        try {\n          return registryItemSchema.parse(result)\n        } catch (error) {\n          throw new RegistryParseError(item, error)\n        }\n      }\n\n      const path = `r/styles/${config?.style ?? 'default'}/${item}.json`\n      const [result] = await fetchRegistry([path], options)\n      try {\n        return registryItemSchema.parse(result)\n      } catch (error) {\n        throw new RegistryParseError(item, error)\n      }\n    }),\n  )\n\n  return results\n}\n\nfunction resolveRegistryItemsFromRegistries(\n  items: Array<string>,\n  config: Config,\n) {\n  const registryHeaders: Record<string, Record<string, string>> = {}\n  const resolvedItems = [...items]\n\n  if (!config?.registries) {\n    setRegistryHeaders({})\n    return resolvedItems\n  }\n\n  for (let i = 0; i < resolvedItems.length; i++) {\n    const itemName = resolvedItems[i]\n    if (!itemName) continue\n\n    const resolved = buildUrlAndHeadersForRegistryItem(itemName, config)\n\n    if (resolved?.url) {\n      resolvedItems[i] = resolved.url\n\n      if (Object.keys(resolved.headers).length > 0) {\n        registryHeaders[resolved.url] = resolved.headers\n      }\n    }\n  }\n\n  setRegistryHeaders(registryHeaders)\n\n  return resolvedItems\n}\n\nexport async function registryResolveItemsTree(\n  names: Array<string>,\n  config: Config,\n  options: { useCache?: boolean } = {},\n) {\n  options = {\n    useCache: true,\n    ...options,\n  }\n\n  clearRegistryContext()\n\n  const payload: Array<z.infer<typeof registryItemSchema>> = []\n  const uniqueNames = Array.from(new Set(names))\n\n  const results = await fetchRegistryItems(uniqueNames, config, options)\n\n  for (let i = 0; i < results.length; i++) {\n    const item = results[i]\n    if (item) {\n      payload.push(item)\n\n      if (item.registryDependencies) {\n        const deps = await resolveDependenciesRecursively(\n          item.registryDependencies,\n          config,\n          options,\n          new Set(uniqueNames),\n        )\n        payload.push(...deps)\n      }\n    }\n  }\n\n  if (!payload.length) {\n    return null\n  }\n\n  let docs = ''\n  payload.forEach((item) => {\n    if (item.docs) {\n      docs += `${item.docs}\\n`\n    }\n  })\n\n  const parsed = registryResolvedItemsTreeSchema.parse({\n    dependencies: deepmerge.all(payload.map((item) => item.dependencies ?? [])),\n    devDependencies: deepmerge.all(\n      payload.map((item) => item.devDependencies ?? []),\n    ),\n    files: deepmerge.all(payload.map((item) => item.files ?? [])),\n    tailwind: payload.reduce(\n      (acc, item) => deepmerge(acc, item.tailwind ?? {}),\n      {},\n    ),\n    cssVars: payload.reduce(\n      (acc, item) => deepmerge(acc, item.cssVars ?? {}),\n      {},\n    ),\n    docs,\n  })\n\n  return parsed\n}\n\nasync function resolveDependenciesRecursively(\n  dependencies: Array<string>,\n  config: Config,\n  options: { useCache?: boolean } = {},\n  visited: Set<string> = new Set(),\n): Promise<Array<z.infer<typeof registryItemSchema>>> {\n  const items: Array<z.infer<typeof registryItemSchema>> = []\n\n  for (const dep of dependencies) {\n    if (visited.has(dep)) {\n      continue\n    }\n    visited.add(dep)\n\n    if (isUrl(dep) || isLocalFile(dep)) {\n      const [item] = await fetchRegistryItems([dep], config, options)\n      if (item) {\n        items.push(item)\n        if (item.registryDependencies) {\n          const resolvedDeps = config?.registries\n            ? resolveRegistryItemsFromRegistries(\n                item.registryDependencies,\n                config,\n              )\n            : item.registryDependencies\n\n          const nested = await resolveDependenciesRecursively(\n            resolvedDeps,\n            config,\n            options,\n            visited,\n          )\n          items.push(...nested)\n        }\n      }\n    } else if (dep.startsWith('@') && config?.registries) {\n      const { registry } = parseRegistryAndItemFromString(dep)\n      if (registry && !(registry in config.registries)) {\n        throw new RegistryNotConfiguredError(registry)\n      }\n\n      const [item] = await fetchRegistryItems([dep], config, options)\n      if (item) {\n        items.push(item)\n        if (item.registryDependencies) {\n          const resolvedDeps = config?.registries\n            ? resolveRegistryItemsFromRegistries(\n                item.registryDependencies,\n                config,\n              )\n            : item.registryDependencies\n\n          const nested = await resolveDependenciesRecursively(\n            resolvedDeps,\n            config,\n            options,\n            visited,\n          )\n          items.push(...nested)\n        }\n      }\n    } else {\n      try {\n        const [item] = await fetchRegistryItems([dep], config, options)\n        if (item && item.registryDependencies) {\n          const resolvedDeps = config?.registries\n            ? resolveRegistryItemsFromRegistries(\n                item.registryDependencies,\n                config,\n              )\n            : item.registryDependencies\n\n          const nested = await resolveDependenciesRecursively(\n            resolvedDeps,\n            config,\n            options,\n            visited,\n          )\n          items.push(...nested)\n        }\n      } catch (error) {\n        continue\n      }\n    }\n  }\n\n  return items\n}\n\nexport async function getRegistryItem(config: Config, name: string) {\n  const [item] = await fetchRegistryItems([name], config)\n  return item\n}\n\nexport async function getRegistryBaseColors() {\n  return [\n    {\n      name: 'neutral',\n      label: 'Neutral',\n    },\n    {\n      name: 'gray',\n      label: 'Gray',\n    },\n    {\n      name: 'zinc',\n      label: 'Zinc',\n    },\n    {\n      name: 'stone',\n      label: 'Stone',\n    },\n    {\n      name: 'slate',\n      label: 'Slate',\n    },\n  ]\n}\n\nexport async function getRegistryBaseColor(config: Config, baseColor: string) {\n  try {\n    const [result] = await fetchRegistry([`colors/${baseColor}.json`])\n\n    return registryBaseColorSchema.parse(result)\n  } catch (error) {\n    handleError(error)\n  }\n}\n\nexport function getRegistryItemFileTargetPath(\n  file: {\n    path: string\n    content?: string\n    type: z.infer<typeof registryItemSchema>['type']\n    target?: string\n  },\n  config: Config,\n  override?: string,\n) {\n  if (override) {\n    return override\n  }\n\n  if (file.type === 'registry:ui') {\n    return config.resolvedPaths.ui\n  }\n\n  if (file.type === 'registry:lib') {\n    return config.resolvedPaths.lib\n  }\n\n  if (file.type === 'registry:block' || file.type === 'registry:component') {\n    return config.resolvedPaths.components\n  }\n\n  if (file.type === 'registry:hook') {\n    return config.resolvedPaths.hooks\n  }\n\n  if (file.type === 'registry:page') {\n    return config.resolvedPaths.components\n  }\n\n  return config.resolvedPaths.components\n}\n\nexport { clearRegistryContext } from '#utils/registry/context'\nexport { parseRegistryAndItemFromString } from '#utils/registry/parser'\n"],"mappings":"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","names":["deepmerge","getRegistryIndex","config","namespace","path","RegistryNotConfiguredError","registryConfig","headers","buildHeadersFromRegistryConfig","indexUrl","expandEnvVars","setRegistryHeaders","result","fetchRegistry","registryIndexSchema","error","logger","handleError","clearRegistryContext","getRegistryStyles","stylesSchema","fetchRegistryItems","items","options","item","isLocalFile","fetchRegistryLocal","isUrl","registryItemSchema","RegistryParseError","paths","resolveRegistryItemsFromRegistries","registryHeaders","resolvedItems","i","itemName","resolved","buildUrlAndHeadersForRegistryItem","registryResolveItemsTree","names","payload","uniqueNames","results","deps","resolveDependenciesRecursively","docs","registryResolvedItemsTreeSchema","deepmerge","acc","dependencies","visited","dep","resolvedDeps","nested","registry","parseRegistryAndItemFromString","getRegistryItem","name","getRegistryItemFileTargetPath","file","config","override"]}