{"version":3,"sources":["../src/utils/detect-monorepo.ts","../src/utils/get-config.ts","../src/utils/resolve-import.ts","../src/utils/systems.ts","../src/utils/transformers/transform-import.ts","../src/utils/transformers/transform-rsc.ts","../src/utils/transformers/index.ts","../src/utils/transformers/transform-jsx.ts"],"sourcesContent":["import { existsSync, readFileSync } from 'node:fs'\nimport path from 'node:path'\n\nexport interface MonorepoInfo {\n  isMonorepo: boolean\n  root?: string\n  packageName?: string\n  type?: 'turborepo' | 'pnpm' | 'yarn' | 'npm'\n}\n\nexport async function detectMonorepo(cwd: string): Promise<MonorepoInfo> {\n  const packageJsonPath = path.join(cwd, 'package.json')\n\n  if (!existsSync(packageJsonPath)) {\n    return { isMonorepo: false }\n  }\n\n  const packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf8'))\n  const packageName = packageJson.name\n\n  const isWorkspacePackage = packageName && /^@[^/]+\\/[^/]+/.test(packageName)\n\n  let currentDir = cwd\n  let depth = 0\n  const maxDepth = 5\n\n  while (depth < maxDepth) {\n    if (existsSync(path.join(currentDir, 'turbo.json'))) {\n      return {\n        isMonorepo: true,\n        root: currentDir,\n        packageName,\n        type: 'turborepo',\n      }\n    }\n\n    if (existsSync(path.join(currentDir, 'pnpm-workspace.yaml'))) {\n      return {\n        isMonorepo: true,\n        root: currentDir,\n        packageName,\n        type: 'pnpm',\n      }\n    }\n\n    const rootPackageJsonPath = path.join(currentDir, 'package.json')\n    if (existsSync(rootPackageJsonPath) && currentDir !== cwd) {\n      try {\n        const rootPackageJson = JSON.parse(\n          readFileSync(rootPackageJsonPath, 'utf8'),\n        )\n        if (rootPackageJson.workspaces) {\n          return {\n            isMonorepo: true,\n            root: currentDir,\n            packageName,\n            type: Array.isArray(rootPackageJson.workspaces) ? 'npm' : 'yarn',\n          }\n        }\n      } catch {\n        continue\n      }\n    }\n\n    const parentDir = path.dirname(currentDir)\n    if (parentDir === currentDir) break\n    currentDir = parentDir\n    depth++\n  }\n\n  if (isWorkspacePackage) {\n    return {\n      isMonorepo: true,\n      packageName,\n    }\n  }\n\n  return { isMonorepo: false }\n}\n\nexport function hasMonorepoAliases(aliases: Record<string, string>): boolean {\n  const values = Object.values(aliases)\n  return values.some((value) => /^@[^/]+\\/[^/]+/.test(value))\n}\n\nexport function getMonorepoPackagePrefix(\n  aliases: Record<string, string>,\n): string | null {\n  for (const value of Object.values(aliases)) {\n    const match = value.match(/^(@[^/]+\\/[^/]+)/)\n    if (match && match[1]) {\n      return match[1]\n    }\n  }\n  return null\n}\n\nexport function monorepoAliasToPath(\n  alias: string,\n  packagePrefix: string,\n): string {\n  const relativePath = alias.replace(packagePrefix, '')\n\n  if (relativePath.startsWith('/')) {\n    return `./src${relativePath}`\n  }\n\n  return `./src/${relativePath}`\n}\n","import { cosmiconfig } from 'cosmiconfig'\nimport path from 'node:path'\nimport { loadConfig } from 'tsconfig-paths'\nimport { z } from 'zod'\n\nimport { detectMonorepo, hasMonorepoAliases } from '#utils/detect-monorepo'\nimport { highlighter } from '#utils/highlighter'\nimport { resolveImport } from '#utils/resolve-import'\n\nimport { SYSTEMS } from './systems'\n\nexport const DEFAULT_STYLE = 'default'\nexport const DEFAULT_COMPONENTS = '@/components'\nexport const DEFAULT_UTILS = '@/lib/utils'\n\n// TODO: Figure out if we want to support all cosmiconfig formats.\n// A simple components.json file would be nice.\nconst explorer = cosmiconfig('components', {\n  searchPlaces: ['components.json'],\n})\n\nexport const rawConfigSchema = z\n  .object({\n    $schema: z.string().optional(),\n    system: z.enum(Object.keys(SYSTEMS)).optional().default('chakra'),\n    style: z.string().optional().default('default'),\n    rsc: z.coerce.boolean().default(false),\n    tsx: z.coerce.boolean().default(true),\n    // theme: z.object({\n    //   config: z.string(),\n    // }),\n    aliases: z.object({\n      components: z.string(),\n      utils: z.string(),\n      ui: z.string().optional(),\n      lib: z.string().optional(),\n      hooks: z.string().optional(),\n      icons: z.string().optional(),\n    }),\n    icons: z\n      .object({\n        outputDir: z.string().optional(),\n        defaultIconSet: z.string().optional(),\n        iconSize: z.string().optional(),\n        aliases: z.record(z.string()).optional(),\n      })\n      .optional(),\n  })\n  .strict()\n\nexport type RawConfig = z.infer<typeof rawConfigSchema>\n\nexport const configSchema = rawConfigSchema.extend({\n  resolvedPaths: z.object({\n    cwd: z.string(),\n    utils: z.string(),\n    components: z.string(),\n    lib: z.string(),\n    hooks: z.string(),\n    ui: z.string(),\n    icons: z.string(),\n  }),\n})\n\nexport type Config = z.infer<typeof configSchema>\n\nexport async function getConfig(cwd: string) {\n  const config = await getRawConfig(cwd)\n\n  if (!config) {\n    return null\n  }\n\n  return await resolveConfigPaths(cwd, config)\n}\n\nexport async function resolveConfigPaths(cwd: string, config: RawConfig) {\n  const monorepoInfo = await detectMonorepo(cwd)\n  const isMonorepo =\n    monorepoInfo.isMonorepo || hasMonorepoAliases(config.aliases)\n\n  const tsConfig = loadConfig(cwd)\n\n  if (tsConfig.resultType === 'failed') {\n    throw new Error(\n      `Failed to load ${config.tsx ? 'tsconfig' : 'jsconfig'}.json. ${\n        tsConfig.message ?? ''\n      }`.trim(),\n    )\n  }\n\n  const resolveAlias = async (alias: string): Promise<string> => {\n    if (isMonorepo && /^@[^/]+\\/[^/]+/.test(alias)) {\n      const match = alias.match(/^@[^/]+\\/[^/]+\\/(.+)$/)\n      if (match && match[1]) {\n        const relativePath = match[1]\n        return path.resolve(cwd, 'src', relativePath)\n      }\n      return path.resolve(cwd, 'src')\n    }\n\n    const resolved = await resolveImport(alias, tsConfig)\n    return resolved ?? path.resolve(cwd, 'src')\n  }\n\n  return configSchema.parse({\n    ...config,\n    resolvedPaths: {\n      cwd,\n      utils: await resolveAlias(config.aliases['utils']),\n      components: await resolveAlias(config.aliases['components']),\n      ui: config.aliases['ui']\n        ? await resolveAlias(config.aliases['ui'])\n        : path.resolve(await resolveAlias(config.aliases['components']), 'ui'),\n      lib: config.aliases['lib']\n        ? await resolveAlias(config.aliases['lib'])\n        : path.resolve(await resolveAlias(config.aliases['utils']), '..'),\n      hooks: config.aliases['hooks']\n        ? await resolveAlias(config.aliases['hooks'])\n        : path.resolve(\n            await resolveAlias(config.aliases['components']),\n            '..',\n            'hooks',\n          ),\n      icons: config.aliases['icons']\n        ? await resolveAlias(config.aliases['icons'])\n        : path.resolve(\n            await resolveAlias(config.aliases['components']),\n            'icons',\n          ),\n    },\n  })\n}\n\nexport async function getRawConfig(cwd: string): Promise<RawConfig | null> {\n  try {\n    const configResult = await explorer.search(cwd)\n\n    if (!configResult) {\n      return null\n    }\n\n    return rawConfigSchema.parse(configResult.config)\n  } catch (error) {\n    const componentPath = `${cwd}/components.json`\n    throw new Error(\n      `Invalid configuration found in ${highlighter.info(componentPath)}.`,\n    )\n  }\n}\n","import { type ConfigLoaderSuccessResult, createMatchPath } from 'tsconfig-paths'\n\nexport async function resolveImport(\n  importPath: string,\n  config: Pick<ConfigLoaderSuccessResult, 'absoluteBaseUrl' | 'paths'>,\n) {\n  return createMatchPath(config.absoluteBaseUrl, config.paths)(\n    importPath,\n    undefined,\n    () => true,\n    ['.ts', '.tsx'],\n  )\n}\n","export const SYSTEMS = {\n  chakra: {\n    name: 'chakra',\n    label: 'Chakra UI',\n  },\n  panda: {\n    name: 'panda',\n    label: 'Panda CSS',\n  },\n} as const\n\nexport type System = (typeof SYSTEMS)[keyof typeof SYSTEMS]\n\nexport const getSystem = (name: string): System | undefined => {\n  return SYSTEMS[name as keyof typeof SYSTEMS]\n}\n","import type { Config } from '#utils/get-config'\nimport type { Transformer } from '#utils/transformers'\n\nexport const transformImport: Transformer = async ({ sourceFile, config }) => {\n  const importDeclarations = sourceFile.getImportDeclarations()\n\n  for (const importDeclaration of importDeclarations) {\n    const moduleSpecifier = updateImportAliases(\n      importDeclaration.getModuleSpecifierValue(),\n      config,\n    )\n\n    importDeclaration.setModuleSpecifier(moduleSpecifier)\n  }\n\n  return sourceFile\n}\n\nfunction updateImportAliases(moduleSpecifier: string, config: Config) {\n  // Not a local import.\n  if (!moduleSpecifier.startsWith('@/') && !moduleSpecifier.startsWith('#')) {\n    return moduleSpecifier\n  }\n\n  // Not a registry import.\n  if (\n    !moduleSpecifier.startsWith('@/registry/') &&\n    !moduleSpecifier.startsWith('#registry/')\n  ) {\n    const isMonorepoConfig = /^@[^/]+\\/[^/]+/.test(config.aliases.components)\n    if (isMonorepoConfig) {\n      return moduleSpecifier\n    }\n\n    const alias = config.aliases.components.charAt(0)\n    return moduleSpecifier.replace(/^@\\//, `${alias}/`)\n  }\n\n  if (moduleSpecifier.match(/^(@\\/|#)registry\\/(.+)\\/ui/)) {\n    return moduleSpecifier.replace(\n      /^(@\\/|#)registry\\/(.+)\\/ui/,\n      config.aliases.ui ?? `${config.aliases.components}/ui`,\n    )\n  }\n\n  if (\n    config.aliases.components &&\n    moduleSpecifier.match(/^(@\\/|#)registry\\/(.+)\\/components/)\n  ) {\n    return moduleSpecifier.replace(\n      /^(@\\/|#)registry\\/(.+)\\/components/,\n      config.aliases.components,\n    )\n  }\n\n  if (config.aliases.lib && moduleSpecifier.match(/^@\\/registry\\/(.+)\\/lib/)) {\n    return moduleSpecifier.replace(\n      /^@\\/registry\\/(.+)\\/lib/,\n      config.aliases.lib,\n    )\n  }\n\n  if (\n    config.aliases.hooks &&\n    moduleSpecifier.match(/^(@\\/|#)registry\\/(.+)\\/hooks/)\n  ) {\n    return moduleSpecifier.replace(\n      /^(@\\/|#)registry\\/(.+)\\/hooks/,\n      config.aliases.hooks,\n    )\n  }\n\n  if (\n    config.aliases.icons &&\n    moduleSpecifier.match(/^(@\\/|#)registry\\/(.+)\\/icons/)\n  ) {\n    return moduleSpecifier.replace(\n      /^(@\\/|#)registry\\/(.+)\\/icons/,\n      config.aliases.icons,\n    )\n  }\n\n  return moduleSpecifier.replace(\n    /^@\\/registry\\/[^/]+/,\n    config.aliases.components,\n  )\n}\n","import { SyntaxKind } from 'ts-morph'\n\nimport type { Transformer } from '#utils/transformers'\n\nexport const transformRsc: Transformer = async ({ sourceFile, config }) => {\n  if (config.rsc) {\n    return sourceFile\n  }\n\n  // Remove \"use client\" from the top of the file.\n  const first = sourceFile.getFirstChildByKind(SyntaxKind.ExpressionStatement)\n  if (first?.getText() === `\"use client\"`) {\n    first.remove()\n  }\n\n  return sourceFile\n}\n","import { promises as fs } from 'node:fs'\nimport { tmpdir } from 'node:os'\nimport path from 'node:path'\nimport { Project, ScriptKind, type SourceFile } from 'ts-morph'\nimport { z } from 'zod'\n\nimport type { Config } from '#utils/get-config'\nimport { registryBaseColorSchema } from '#utils/registry/schema'\nimport { transformImport } from '#utils/transformers/transform-import'\nimport { transformJsx } from '#utils/transformers/transform-jsx'\nimport { transformRsc } from '#utils/transformers/transform-rsc'\n\nexport type TransformOpts = {\n  filename: string\n  raw: string\n  config: Config\n  baseColor?: z.infer<typeof registryBaseColorSchema>\n  transformJsx?: boolean\n}\n\nexport type Transformer<Output = SourceFile> = (\n  opts: TransformOpts & {\n    sourceFile: SourceFile\n  },\n) => Promise<Output>\n\nconst project = new Project({\n  compilerOptions: {},\n})\n\nasync function createTempSourceFile(filename: string) {\n  const dir = await fs.mkdtemp(path.join(tmpdir(), 'sui-'))\n  return path.join(dir, filename)\n}\n\nexport async function transform(\n  opts: TransformOpts,\n  transformers: Transformer[] = [transformImport, transformRsc],\n) {\n  const tempFile = await createTempSourceFile(opts.filename)\n  const sourceFile = project.createSourceFile(tempFile, opts.raw, {\n    scriptKind: ScriptKind.TSX,\n  })\n\n  for (const transformer of transformers) {\n    transformer({ sourceFile, ...opts })\n  }\n\n  if (opts.transformJsx) {\n    return await transformJsx({\n      sourceFile,\n      ...opts,\n    })\n  }\n\n  return sourceFile.getText()\n}\n","import * as recast from 'recast'\nimport { transformFromAstSync } from '@babel/core'\nimport { type ParserOptions, parse } from '@babel/parser'\n// @ts-ignore\nimport transformTypescript from '@babel/plugin-transform-typescript'\n\nimport { type Transformer } from '#utils/transformers'\n\n// TODO.\n// I'm using recast for the AST here.\n// Figure out if ts-morph AST is compatible with Babel.\n\n// This is a copy of the babel options from recast/parser.\n// The goal here is to tolerate as much syntax as possible.\n// We want to be able to parse any valid tsx code.\n// See https://github.com/benjamn/recast/blob/master/parsers/_babel_options.ts.\nconst PARSE_OPTIONS: ParserOptions = {\n  sourceType: 'module',\n  allowImportExportEverywhere: true,\n  allowReturnOutsideFunction: true,\n  startLine: 1,\n  tokens: true,\n  plugins: [\n    'asyncGenerators',\n    'bigInt',\n    'classPrivateMethods',\n    'classPrivateProperties',\n    'classProperties',\n    'classStaticBlock',\n    'decimal',\n    'decorators-legacy',\n    'doExpressions',\n    'dynamicImport',\n    'exportDefaultFrom',\n    'exportNamespaceFrom',\n    'functionBind',\n    'functionSent',\n    'importAssertions',\n    'importMeta',\n    'nullishCoalescingOperator',\n    'numericSeparator',\n    'objectRestSpread',\n    'optionalCatchBinding',\n    'optionalChaining',\n    [\n      'pipelineOperator',\n      {\n        proposal: 'minimal',\n      },\n    ],\n    [\n      'recordAndTuple',\n      {\n        syntaxType: 'hash',\n      },\n    ],\n    'throwExpressions',\n    'topLevelAwait',\n    'v8intrinsic',\n    'typescript',\n    'jsx',\n  ],\n}\n\nexport const transformJsx: Transformer<string> = async ({\n  sourceFile,\n  config,\n}) => {\n  const output = sourceFile.getFullText()\n\n  if (config.tsx) {\n    return output\n  }\n\n  const ast = recast.parse(output, {\n    parser: {\n      parse: (code: string) => {\n        return parse(code, PARSE_OPTIONS)\n      },\n    },\n  })\n\n  const result = transformFromAstSync(ast, output, {\n    cloneInputAst: false,\n    code: false,\n    ast: true,\n    plugins: [transformTypescript],\n    configFile: false,\n  })\n\n  if (!result || !result.ast) {\n    throw new Error('Failed to transform JSX')\n  }\n\n  return recast.print(result.ast).code\n}\n"],"mappings":"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","names":["existsSync","readFileSync","path","detectMonorepo","cwd","packageJsonPath","packageName","isWorkspacePackage","currentDir","depth","maxDepth","rootPackageJsonPath","rootPackageJson","parentDir","hasMonorepoAliases","aliases","value","cosmiconfig","path","loadConfig","z","createMatchPath","resolveImport","importPath","config","SYSTEMS","DEFAULT_COMPONENTS","DEFAULT_UTILS","explorer","cosmiconfig","rawConfigSchema","z","SYSTEMS","configSchema","getConfig","cwd","config","getRawConfig","resolveConfigPaths","isMonorepo","detectMonorepo","hasMonorepoAliases","tsConfig","loadConfig","resolveAlias","alias","match","relativePath","path","resolveImport","configResult","componentPath","highlighter","transformImport","sourceFile","config","importDeclarations","importDeclaration","moduleSpecifier","updateImportAliases","alias","SyntaxKind","transformRsc","sourceFile","config","first","fs","tmpdir","path","Project","ScriptKind","recast","transformFromAstSync","parse","transformTypescript","PARSE_OPTIONS","transformJsx","sourceFile","config","output","ast","code","parse","result","transformFromAstSync","transformTypescript","project","Project","createTempSourceFile","filename","dir","fs","path","tmpdir","transform","opts","transformers","transformImport","transformRsc","tempFile","sourceFile","ScriptKind","transformer","transformJsx"]}